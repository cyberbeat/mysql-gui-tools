{
	Delphi Scintilla Interface Components
	Copyright (C) 2004,2005 Jan Martin Pettersen (hdalis)

	This library is free software; you can redistribute it and/or
	modify it under the terms of the GNU Lesser General Public
	License as published by the Free Software Foundation; either
	version 2.1 of the License, or (at your option) any later
	version.

	This library is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
	Lesser General Public License for more details.

	You should have received a copy of the GNU Lesser General Public
	License along with this library; if not, write to the Free
	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
	02111-1307 USA
}
{
  Author : Jan Martin Pettersen (hdalis@users.sourceforge.net)
	Purpose: Used by ClassExplorer to generate help.
	         Found at http://www.toolsfactory.com/classexplorer.html (freeware)
      $Id: helpdescriptions.txt,v 1.4 2004/11/13 04:29:51 hdalis Exp $
	Created: 13/10/2004, 22:24:49
  History: 18/10/2004  Initial Release
           21/10/2004  Imported most of the help from the original Scintilla help into
                       the help for TScintillaBase. Formatted, and changed the names
                       to fit the class.
                       The original help for Scintilla can be found in the Scintilla Project
                       (http://www.scintilla.org)
           02/11/2004  Updated the help for TScintillaBase with version 1.62 of Scintilla
           11/11/2004  Updated the help for SciLexerMod.Pas.
					 01/12/2004- 
					 04/01/2005  Added assorted new items.
					             Added extra help to the gutter0-2 for how to set colors.
}
//----------- Assorted help
//CE_Desc_Begin(@LIST_OVERVIEW)
{List of all classes in the project.}
//CE_Desc_End
//CE_Desc_Begin(@HIERARCHY_OVERVIEW)
{Hierarchical overview of the classes in the project.}
//CE_Desc_End
//CE_Desc_Begin(@UNIT_OVERVIEW)
{Units in the project.}
//CE_Desc_End
//CE_Desc_Begin(SciControllerHandler.Pas)
{Manages notification to multiple components when some events occur.}
//CE_Desc_End

//----------- SciAbbrevationManager.Pas
//CE_Desc_Begin(SciAbbrevationManager.Pas)
{Abbrevation manager.}
//CE_Desc_End

//CE_Desc_Begin(TSciAbbrevManager)
{Manages abbrevations.}
//CE_Desc_End
//CE_Desc_Begin(TSciAbbrevManager.Abbrevations)
{The abbrevations defined in the format name=abbrevation

You can use the \r \n etc escapesequenses from C++ (not octals however).
Use '|' to define the position you want the cursor in.
If you want to use the | character itself, use it like this: ||.

You can reference other templates like this:
<^othertemplatename>

You can reference builtin templates (either which is built into TSciAbbrevManager,
or parsed via the <%LINK OnTemplateMacro%> event like this:

<^$templatemacroname(param1 param2 param3>.

Parameters is separated by a SINGLE ' ' character.
There are two predefined templatemacros:

PROMPT "Prompt" "WindowCaption"
ROW    Returns the current row.
}
//CE_Desc_End

//CE_Desc_Begin(TSciAbbrevManager.Editor)
{The linked editor.}
//CE_Desc_End
//CE_Desc_Begin(TSciAbbrevManager.IgnoreCase)
{If True, then the names of the abbrevations isn't casesensitive.}
//CE_Desc_End
//CE_Desc_Begin(TSciAbbrevManager.OnTemplateMacro)
{Fired when expanding a template to allow you to interpret additional builtin templatemacros.
Return your result in 'RetVal'.
}
//CE_Desc_End

//----------- sciUtils.pas

//+++++++++++ Routines

//CE_Desc_Begin(ColourFromString)
{Convert a string to the corresponding TColor, or if s='' then returns defcolor.
<%RETURNS%>The converted color.}
//CE_Desc_End
//CE_Desc_Begin(ColourToString)
{Converts a TColor to a string readable by ColourFromString (either a htmlcolorcode, or
a clXXXX color name).
<%RETURNS%>The colorstring.}
//CE_Desc_End
//CE_Desc_Begin(ValueExtract)
{Extracts a value from a property in the format valuename:value
<%RETURNS%>The value part.}
//CE_Desc_End
//CE_Desc_Begin(CompStr)
{Compares 's1' to 's2', and if 'ignorecase' is true then the comparing is caseless.
If 'maxlen'<>-1 then only maxlen chars are compared.}
//CE_Desc_End
//CE_Desc_Begin(StringToBool)
{Converts a string to a boolean.

If the string is 'True', '1' or 'Yes' the return value is True, else it's false.

The comparing is caseless.}
//CE_Desc_End

//CE_Desc_Begin(BoolToString)
{Converts a boolean to a string.

Returns 'True' if True, else it returns 'False'.}
//CE_Desc_End
//CE_Desc_Begin(ValueFromIndex)
{This function exists in the TStrings class in Delphi 7 but not in C++ Builder 6 therefore a wrapper for it.

}
//CE_Desc_End
//CE_Desc_Begin(StrToken)
{Extracts the string from start to 'separator'. Returns that, and returns the rest of the string in 's'.}
//CE_Desc_End
//CE_Desc_Begin(StrReplaceChar)
{Replaces the all 'source' char with 'replace' char, and returns the result.}
//CE_Desc_End

//----------- EdOptionsWin.pas
//CE_Desc_Begin(EdOptionsWin.pas)
{Editor options form. Internal, used by TScintillaOptionsDlg component.}
//CE_Desc_End
//CE_Desc_Begin(TEditorOptions)
{Internal class, used by the TEdOptionsWindow class.}
//CE_Desc_End
//CE_Desc_Begin(TEditorOptions.Assign)
{Assigns the settings from 'Source' to this object.}
//CE_Desc_End

//CE_Desc_Begin(TEdOptionsWindow)
{Internal class, used by the TScintillaOptionsDlg component.}
//CE_Desc_End

//----------- SciDetectUtils.pas
//CE_Desc_Begin(SciDetectUtils.pas)
{Assorted utilities for detecting language based on file extension, and
changing the wordchars based on language.
}
//CE_Desc_End

//+++++++++++ Routines

<%NOTE%>Do NOT free the returned classptr.}
//CE_Desc_End
//CE_Desc_Begin(SetLangWordChars)
{Sets what chars is wordchars for the language 'lang'}
//CE_Desc_End

//----------- SciDocuments.pas
//CE_Desc_Begin(SciDocuments.pas)
{Tabbed scintilla component.}
//CE_Desc_End

//+++++++++++ TSciDoc

//CE_Desc_Begin(TSciDoc)
{Stores the different documents in a <%LINK TSciDocumentTabControl%>}
//CE_Desc_End
//CE_Desc_Begin(TSciDoc.Activate)
{Activates this document}
//CE_Desc_End
//CE_Desc_Begin(TSciDoc.IsUntitled)
{Returns true if the document is untitled, otherwise false.}
//CE_Desc_End
//CE_Desc_Begin(TSciDoc.Indentation)
{The Indentation flags for the document.<%SEEALSO TScintillaMemo.Indentation%>}
//CE_Desc_End
//CE_Desc_Begin(TSciDoc.TabWidth)
{The tab width of the document.<%SEEALSO TScintillaMemo.TabWidth%>}
//CE_Desc_End
//CE_Desc_Begin(TSciDoc.IndentWidth)
{The indentation width of the document.<%SEEALSO TScintillaMemo.IndentWidth%>}
//CE_Desc_End
//CE_Desc_Begin(TSciDoc.Modified)
{The Modified status of the document.<%SEEALSO TScintillaBase.Modified%>}
//CE_Desc_End
//CE_Desc_Begin(TSciDoc.IsActive)
{Tests wether this document is active.

<%RETURNS%>True if this document is active, else False.}
//CE_Desc_End
//CE_Desc_Begin(TSciDoc.TabName)
{The name/description of this tab. Displayed on the tab.
Also set by <%LINK TSciDoc.FileName%> to the filename.ext part.}
//CE_Desc_End
//CE_Desc_Begin(TSciDoc.Highlighter)
{The language/lexer used in this document. <%SEEALSO TSciLanguageManager.SelectedLanguage%>
Maps to TScintillaMemo.Highlighter.SelectedLanguage.

If the current editor is a TScintilla derived class then this property are automatically saved and used.
}
//CE_Desc_End
//CE_Desc_Begin(TSciDoc.WordChars)
{Maps to TScintillaBase.WordChars.}
//CE_Desc_End
//CE_Desc_Begin(TSciDoc.Index)
{Tab/Document index of this document.}
//CE_Desc_End
//CE_Desc_Begin(TSciDoc.FileName)
{The filename of this document.}
//CE_Desc_End

//+++++++++++ TSciDocumentTabControl

//CE_Desc_Begin(TSciDocumentTabControl)
{Make a scintilla control tabbed. Add this control and a TScintillaBase derived control to the
form. Select the editor to use with the Editor property, and viola Tabbed Scintilla Control.
}
//CE_Desc_End
//CE_Desc_Begin(TSciDocumentTabControl.Close)
{Closes the currently selected tab/document. Fires the <%LINK TSciDocumentTabControl.OnClosing,OnClosing%> event.}
//CE_Desc_End

//CE_Desc_Begin(TSciDocumentTabControl.ActiveDocument)
{The current document.}
//CE_Desc_End
//CE_Desc_Begin(TSciDocumentTabControl.OnClosing)
{Fired when the a document tab is closing.
The document that is closing is made current, i.e ActiveDocument is the closing document.
}
//CE_Desc_End

//CE_Desc_Begin(TSciDocumentTabControl.OnOpenedAndInited)
{Fired right after a new document has gotten it's highlighter (by a previous OnDetectHighlighter call) and loaded,
ready for any highlighter specific/other changes.
}
//CE_Desc_End

//CE_Desc_Begin(TSciDocumentTabControl.NewDocument)
{Creates a new document.

<%RETURNS%>The document index.}
//CE_Desc_End
//CE_Desc_Begin(TSciDocumentTabControl.DefaultExt)
{Sets the default extension for new documents.}
//CE_Desc_End
//CE_Desc_Begin(TSciDocumentTabControl.Count)
{Number of tabs/documents open.}
//CE_Desc_End
//CE_Desc_Begin(TSciDocumentTabControl.Attach)
{Attaches the Editor to this tabcontrol. Internal.}
//CE_Desc_End
//CE_Desc_Begin(TSciDocumentTabControl.RefreshTabs)
{Refreshes the tablist based on the internal TObjectList.}
//CE_Desc_End
//CE_Desc_Begin(TSciDocumentTabControl.Change)
{Overrided to change the currently visible document when tab changes.}
//CE_Desc_End
//CE_Desc_Begin(TSciDocumentTabControl.CanChange)
{Overrided to test if the selected tab has a document, and if not, deny change.}
//CE_Desc_End

//CE_Desc_Begin(TSciDocumentTabControl.Document)
{Returns the selected <%LINK TSciDoc,document%>.}
//CE_Desc_End
//CE_Desc_Begin(TSciDocumentTabControl.Editor)
{The linked TScintillaBase derived editor to use}
//CE_Desc_End
//CE_Desc_Begin(TSciDocumentTabControl.OnDetectHighlighter)
{Fired when a document is added etc. Gives an opportunity to tell the control
what lexer/language should be used.}
//CE_Desc_End
//CE_Desc_Begin(TSciDocumentTabControl.Activate)
{Activates the tab/document 'docno'}
//CE_Desc_End
//CE_Desc_Begin(TSciDocumentTabControl.Add)
{Add a tab/document, set the tabname to 'tabname'

<%RETURNS%>The new tab/document index.}
//CE_Desc_End
//CE_Desc_Begin(TSciDocumentTabControl.Remove)
{Removes the tab/document 'index'.}
//CE_Desc_End
//CE_Desc_Begin(TSciDocumentTabControl.Open)
{Loads the file 'filename'. Fires the event <%LINK TSciDocumentTabControl.OnDetectHighlighter,OnDetectHighlighter%> to determine
the language/lexer to use.}
//CE_Desc_End

//----------- SciKeyEditForm.pas
//CE_Desc_Begin(SciKeyEditForm.pas)
{The form to assign keys to functions. Internally used.}
//CE_Desc_End
//CE_Desc_Begin(TKeyEditForm)
{Internal class, used by the TEdOptionsWindow class.}
//CE_Desc_End

//CE_Desc_Begin(SciKeyBindings.pas)
{Handles the bindings between keys and functions. Internal classes.
Some routines to convert and handle keys.
}
//CE_Desc_End

//+++++++++++ Routines

//CE_Desc_Begin(SciKeyToKey)
{Convert a Scintilla key to a Virtual Key.

<%RETURNS%>The converted key.<%SEEALSO KeyToSciKey%>}
//CE_Desc_End
//CE_Desc_Begin(KeyToSciKey)
{Convert a virtual key to a Scintilla Key.

<%RETURNS%>The converted key.<%SEEALSO SciKeyToKey%>}
//CE_Desc_End
//CE_Desc_Begin(ShiftStateToSciMode)
{Convert a TShiftState to Scintilla modifiers.

<%RETURNS%>The converted modifier.<%SEEALSO SciModeToShiftState%>
}
//CE_Desc_End
//CE_Desc_Begin(SciModeToShiftState)
{Convert Scintilla modifiers to a TShiftState.

<%RETURNS%>The converted modifier.<%SEEALSO ShiftStateToSciMode%>}
//CE_Desc_End
//CE_Desc_Begin(SciKeyToShortCut)
{Creates a menu shortcut for the specified TSciKey.<%SEEALSO ShortCutToSciKey%>}
//CE_Desc_End
//CE_Desc_Begin(ShortCutToSciKey)
{Returns the TSciKey of a menu shortcut.<%SEEALSO SciKeyToShortCut%>}
//CE_Desc_End
//CE_Desc_Begin(SciKey)
{Convert a Scintilla key and modifiers to a TSciKey.}
//CE_Desc_End

//+++++++++++ TSciKeyCommandCollection
//CE_Desc_Begin(TSciKeyCommandCollection)
{A collection of assigned Keyboard commands.}
//CE_Desc_End
//CE_Desc_Begin(TSciKeyCommandCollection.AddCommandKey)
{Add a new keymapping. 'Mode' is the modifiers for the key. 'Key' is the key itself. 'Command' is the SCI_* command to be executed.}
//CE_Desc_End
//CE_Desc_Begin(TSciKeyCommandCollection.FindShortCut)
{Locates the key/commandmapping for the shortcut 'ShortCut'.}
//CE_Desc_End
//CE_Desc_Begin(TSciKeyCommandCollection.ResetDefaultCommands)
{Resets the keymappings to the default.}
//CE_Desc_End

//+++++++++++ TSciKeyCommand

//CE_Desc_Begin(TSciKeyCommand)
{A single keyboard command.}
//CE_Desc_End
//CE_Desc_Begin(TSciKeyCommand.Assign)
{Assigns the settings from 'Source' to this object.}
//CE_Desc_End

//----------- SciLexer.pas
//CE_Desc_Begin(SciLexer.pas)
{The main interface for the scintilla control. Baseclasses.

 Most of this file was automatically generated from the Scintilla.iface interface definition
 file which contains any comments about the definitions.
 If you need to update this file with the new functionality of a newer scintilla version
 then you must use the scintilla.iface file which can be found in the Scintilla Project (www.scintilla.org)
 PasGen.py does the generation (requires Python).

 Please use the corresponding scintilla.iface file when you regenerate the code.
}
//CE_Desc_End

//+++++++++++ TScintillaBase
//CE_Desc_Begin(TScintillaBase)
{A Delphi wrapper baseclass for the Scintilla editing component (www.scintilla.org).
Scintilla is available for Windows as a Dynamic link library (DLL).
The standard way of interacting with the control is through messages sent to the windows handle of Scintilla.

The Delphi wrapper baseclass and descendants provides Delphi-like convenient access
to the most common functionality of Scintilla, whilst at the same time allowing for communication with
control through methods that hide the sending of messages.

Parts of this class documentation are copied and modified to fit this class from the
Scintilla Documentation.

<%BOLD%>About the TScintillaBase documentation<%TEXT%>

The help for the generated functions extracted from the scintilla.iface
are in most part by the man and his contributors.
The rest are by myself.

Below are the required license for that documentation:

License for Scintilla

Copyright 1998-2004 by Neil Hodgson <neilh@scintilla.org>

All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation.

NEIL HODGSON DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL NEIL HODGSON BE LIABLE FOR ANY
SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
OR PERFORMANCE OF THIS SOFTWARE.}
//CE_Desc_End

{START Imported and customised help (mostly from the Scintilla Project). Added help for functions
where it was none also.}
//CE_Desc_Begin(TScintillaBase.ForceMouseRelease)
{The scintilla control may capture the mouse, and not release it again,
i.e if you singleclick a selection the scintilla control grabs the mouse, and
does'nt release it before you click something outside the control.

Set this to True to force it to release the mouse again when the mouse is
outside the scintilla control, and no mousebuttons are down.}
//CE_Desc_End

//CE_Desc_Begin(TScintillaBase.AddText)
{This inserts the first 'length' characters from the string 's' at the current position. This will include any 0's in the string that you might have expected to stop the insert operation. The current position is set at the end of the inserted text, but it is not scrolled into view.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.AddStyledText)
{This behaves just like <%LINK TScintillaBase.AddText%>, but inserts styled text.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.AppendText)
{This adds the first 'length' characters from the string 's' to the end of the document. This will include any 0's in the string that you might have expected to stop the operation. The current selection is not changed and the new text is not scrolled into view.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.InsertText)
{This inserts the zero terminated text string at position 'pos' or at the current position if 'pos' is -1. The current position is set at the end of the inserted text, but it is not scrolled into view.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.ClearAll)
{Unless the document is read-only, this deletes all the text.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.ClearDocumentStyle)
{When wanting to completely restyle the document, for example after choosing a lexer, the <%LINK TScintillaBase.ClearDocumentStyle%> can be used to clear all styling information and reset the folding state.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetCharAt)
{This returns the character at pos in the document or 0 if 'pos' is negative or past the end of the document.<%SEEALSO GetStyleAt%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetStyleAt)
{This returns the style at 'pos' in the document, or 0 if 'pos' is negative or past the end of the document.<%SEEALSO GetCharAt%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetStyleBits)
{Sets number of bits in each cell to use for styling, to a maximum of 7 style bits. The remaining bits can be used as indicators. The standard setting is 5.<%SEEALSO GetStyleBits%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetStyleBits)
{Returns number of bits in each cell to use for styling, to a maximum of 7 style bits. The remaining bits can be used as indicators. The standard setting is 5.<%SEEALSO SetStyleBits%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SearchAnchor)
{Sets the search start point used by <%LINK TScintillaBase.SearchNext,SearchNext%> and <%LINK TScintillaBase.SearchPrev,SearchPrev%> to the start of the current selection, that is, the end of the selection that is nearer to the start of the document. You should always call this before calling either of <%LINK TScintillaBase.SearchNext,SearchNext%> or <%LINK TScintillaBase.SearchPrev,SearchPrev%>.<%SEEALSO SearchPrev,SearchNext%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SearchNext)
{Search for the next occurrence of the zero terminated search string pointed at by 'text'. The search is modified by the 'searchFlags'.

See <%LINK FindTextX,FindTextX%> for the different 'searchFlags' that exists.<%SEEALSO SearchPrev,SearchAnchor%>

<%RETURNS%> -1 if nothing is found, otherwise the start position of the matching text. The selection is updated to show the matched text, but is not scrolled into view.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SearchPrev)
{Search for the previous occurrence of the zero terminated search string pointed at by 'text'. The search is modified by the 'searchFlags'.
 If you request a regular expression, it finds the first occurrence of the search string in the document, not the previous one before the anchor point.

See <%LINK FindTextX,FindTextX%> for the different 'searchFlags' that exists.<%SEEALSO SearchNext,SearchAnchor%>

<%RETURNS%> -1 if nothing is found, otherwise the start position of the matching text. The selection is updated to show the matched text, but is not scrolled into view.
}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetTargetStart)
{Set the start of the target.
When searching in non-regular expression mode, you can set start greater than end to find the last matching text in the target rather than the first matching text. The target is also set by a successful <%LINK TScintillaBase.SearchInTarget%>.<%SEEALSO GetTargetStart,SetTargetEnd,TargetFromSelection,SetSearchFlags,SearchInTarget,ReplaceTarget,ReplaceTargetRE%>
}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetTargetEnd)
{Set the end of the target.
When searching in non-regular expression mode, you can set start greater than end to find the last matching text in the target rather than the first matching text. The target is also set by a successful <%LINK TScintillaBase.SearchInTarget%>.<%SEEALSO GetTargetEnd,SetTargetStart,TargetFromSelection,SetSearchFlags,SearchInTarget,ReplaceTarget,ReplaceTargetRE%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetTargetStart)
{Returns the start of Target.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetTargetEnd)
{Returns the start of Target.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.TargetFromSelection)
{Set the target start and end to the start and end positions of the selection.<%SEEALSO SetTargetStart,SetTargetEnd,SetSearchFlags,SearchInTarget,ReplaceTarget,ReplaceTargetRE%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetSearchFlags)
{Set the searchFlags used by <%LINK TScintillaBase.SearchInTarget,SearchInTarget%>. There are several option flags including a simple regular expression search.
See <%LINK FindTextX,FindTextX%> for the different 'searchFlags' that exists.<%SEEALSO SetTargetStart,SetTargetEnd,TargetFromSelection,SearchInTarget,ReplaceTarget,ReplaceTargetRE%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetSearchFlags)
{See <%LINK SetSearchFlags%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SearchInTarget)
{This searches for the first occurrence of a text string in the target defined by <%LINK TScintillaBase.SetTargetStart,SetTargetStart%> and <%LINK TScintillaBase.SetTargetEnd,SetTargetEnd%>. The 'text' string is not zero terminated; the size is set by 'length'. The search is modified by the search flags set by <%LINK TScintillaBase.SetSearchFlags,SetSearchFlags%>.
If the search succeeds, the target is set to the found text.

Searching can be performed within the target range with this, which uses a counted string to allow searching for null characters.
It returns the length of range or -1 for failure, in which case the target is not moved.
The flags used such as SCFIND_MATCHCASE, SCFIND_WHOLEWORD, SCFIND_WORDSTART, and SCFIND_REGEXP
can be set with <%LINK TScintillaBase.SetSearchFlags,SetSearchFlags%>.
This may be simpler for some clients to use than <%LINK TScintillaBase.FindTextX,FindTextX%>, as that requires using a pointer to a structure.

<%RETURNS%>Position of the start of the matching text. If the search fails, the result is -1.<%SEEALSO SetTargetStart,SetTargetEnd,TargetFromSelection,SetSearchFlags,ReplaceTarget,ReplaceTargetRE%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.ReplaceTarget)
{If length is -1, 'text' is a zero terminated string, otherwise 'length' sets the number of character to replace the target with.

Using <%LINK TScintillaBase.ReplaceSel,ReplaceSel%>, modifications cause scrolling and other visible changes, which may take some time and cause unwanted display updates.
If performing many changes, such as a replace all command, the target can be used instead. First, set the target, ie. the range to be replaced. Then call <%LINK TScintillaBase.ReplaceTarget,ReplaceTarget%> or <%LINK TScintillaBase.ReplaceTarget,ReplaceTargetRE%>.

Note that the recommanded way to delete text in the document is to set the target to the text to be removed, and to perform a replace target with an empty string.

<%RETURNS%>The return value is the length of the replacement string.<%SEEALSO SetTargetStart,SetTargetEnd,TargetFromSelection,SetSearchFlags,SearchInTarget,ReplaceTargetRE%>
}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.ReplaceTargetRE)
{If length is -1, 'text' is a zero terminated string, otherwise 'length' sets the number of character to replace the target with.
The replacement string is formed from the text string with any sequences of \1 through \9 replaced by tagged matches from the most recent regular expression search.

Using <%LINK TScintillaBase.ReplaceSel,ReplaceSel%>, modifications cause scrolling and other visible changes, which may take some time and cause unwanted display updates.
If performing many changes, such as a replace all command, the target can be used instead. First, set the target, ie. the range to be replaced. Then call <%LINK TScintillaBase.ReplaceTarget,ReplaceTarget%> or <%LINK TScintillaBase.ReplaceTarget,ReplaceTargetRE%>.

<%RETURNS%>The return value is the length of the replacement string.<%SEEALSO SetTargetStart,SetTargetEnd,TargetFromSelection,SetSearchFlags,SearchInTarget,ReplaceTarget%>
}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetAnchor)
{This sets the anchor position and creates a selection between the anchor position and the current position. The caret is not scrolled into view.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetAnchor)
{This returns the current position.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetCurrentPos)
{This sets the current position and creates a selection between the anchor and the current position. The caret is not scrolled into view.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetCurrentPos)
{Returns the current position}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GotoLine)
{This removes any selection and sets the caret at the start of line number line and scrolls the view (if needed) to make it visible. The anchor position is set the same as the current position. If line is outside the lines in the document (first line is 0), the line set is the first or last.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GotoPos)
{This removes any selection, sets the caret at pos and scrolls the view to make the caret visible, if necessary. It is equivalent to <%LINK TScintillaBase.SetSel,SetSel%>(pos, pos). The anchor position is set the same as the current position.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetSel)
{This message sets both the anchor and the current position. If 'currentPos' is negative, it means the end of the document. If 'anchorPos' is negative, it means remove any selection (i.e. set the anchor to the same position as 'currentPos'). The caret is scrolled into view after this operation.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.LineFromPosition)
{This message returns the line that contains the position 'pos' in the document.
The return value is 0 if pos <= 0.
The return value is the last line if pos is beyond the end of the document.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.PositionFromLine)
{This returns the document position that corresponds with the start of the line.
If line is negative, the position of the line holding the start of the selection is returned.
If line is greater than the lines in the document, the return value is -1.
If line is equal to the number of lines in the document (i.e. 1 line past the last line), the return value is the end of the document.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetLineEndPosition)
{This returns the position at the end of the line, before any line end characters.
If line is negative, the result is 0. If line is the last line in the document, (which does not have any end of line characters), the result is the size of the document.
If line is negative, the result is -1. If line is >= <%LINK TScintillaBase.GetLineCount,GetLineCount%>, the result is currently <%LINK TScintillaBase.GetLength,GetLength%>-1... (undefined?).}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.LineLength)
{This returns the length of the line, including any line end characters.
If line is negative or beyond the last line in the document, the result is 0.
If you want the length of the line not including any end of line characters, use <%LINK TScintillaBase.GetLineEndPosition,GetLineEndPosition%>(line) - <%LINK TScintillaBase.PositionFromLine,PositionFromLine%>(line)}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetText)
{This returns length-1 characters of text from the start of the document plus one terminating NULL character.
To collect all the text in a document, use <%LINK TScintillaBase.GetLength,GetLength%> to get the number of characters in the document (nLen),
allocate a character buffer of length nLen+1 bytes, then call GetText(nLen+1, char *text).
If 'text' argument is nil (NULL) then the length that should be allocated to store the entire document is returned.
If you then save the text, you should use <%LINK TScintillaBase.SetSavePoint,SetSavePoint%> to mark the text as unmodified.

<%RETURNS%>The number of characters copied to the buffer.
<%SEEALSO GetSelText,GetCurLine,GetLine,GetStyledText,GetTextRange%>
}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetSelText)
{This copies the currently selected text and a terminating 0 byte to the text buffer. The buffer must be at least SCI_GETSELECTIONEND()-SCI_GETSELECTIONSTART()+1 bytes long.
If the text argument is 0 then the length that should be allocated to store the entire selection is returned.<%SEEALSO GetCurLine,GetLine,GetText,GetStyledText,GetTextRange%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetText)
{This replaces all the text in the document with the zero terminated text string you pass in.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetSavePoint)
{This message tells Scintilla that the current state of the document is unmodified.

This is usually done when the file is saved or loaded, hence the name "save point".

As Scintilla performs undo and redo operations, it notifies the container that it has
entered or left the save point with <%LINK OnSavePointReached%> and <%LINK OnSavePointLeft%> events,
allowing the container to know if the file should be considered dirty or not.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetLine)
{This fills the buffer defined by 'text' with the contents of the nominated line (lines start at 0).
The buffer is not terminated by a 0 character. It is up to you to make sure that
the buffer is long enough for the text, use <%LINK GetLength%>(int line).
The returned 'text' includes any end of line characters.
If you ask for a line number outside the range of lines in the document, 0 characters are copied.
If the text argument is 0 then the length that should be allocated to store the entire line is returned.

<%RETURNS%>The number of characters copied to the buffer.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.ReplaceSel)
{The currently selected text between the anchor and the current position is replaced by the 0 terminated 'text' string.
If the anchor and current position are the same, the text is inserted at the caret position.
The caret is positioned after the inserted text and the caret is scrolled into view.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetTextRange)
{This collects the text between the positions cpMin and cpMax and copies it to lpstrText (see struct <%FLINK TTextRange,TTextRange%>).
If cpMax is -1, text is returned to the end of the document.
The text is 0 terminated, so you must supply a buffer that is at least 1 character longer
than the number of characters you wish to read.

<%RETURNS%>Length of the returned text not including the terminating 0.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetStyledText)
{This collects styled text into a buffer using two bytes for each cell, with the character at
the lower address of each pair and the style byte at the upper address.
Characters between the positions cpMin and cpMax are copied to lpstrText (see struct <%FLINK TTextRange,TTextRange%>).
Two 0 bytes are added to the end of the text, so the buffer that lpstrText points at must be at least 2*(cpMax-cpMin)+2 bytes long.
No check is made for sensible values of cpMin or cpMax.
Positions outside the document return character codes and style bytes of 0.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.Allocate)
{Allocate a document buffer large enough to store a given number of bytes. The document will not be made smaller than its current contents.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.CopyRange)
{Copies a range of text from the document to the system clipboard.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.CopyText)
{Copies a supplied piece of text to the system clipboard.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.Undo)
{Undoes one action, or if the undo buffer has reached a <%LINK EndUndoAction%> point, all the actions back to the corresponding <%LINK BeginUndoAction%>.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.CanUndo)
{Returns True if there changes that can be undone.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.Redo)
{Undoes the effect of the last <%LINK Undo%> operation.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.CanRedo)
{Returns True if there are an undo operation to be undone.}
//CE_Desc_End

//CE_Desc_Begin(TScintillaBase.EmptyUndoBuffer)
{This command tells Scintilla to forget any saved undo or redo history.
It also sets the save point to the start of the undo buffer, so the document
will appear to be unmodified.

<%NOTE%>This does not cause the <%LINK OnSavePointReached%> event to be sent to the container.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetUndoCollection)
{You can control whether Scintilla collects undo information with <%LINK SetUndoCollection%>.
Pass in True to collect information or False to stop collecting.
If you stop collection, you should also use <%LINK EmptyUndoBuffer%> to avoid the undo buffer
being unsynchronized with the data in the buffer.

You might wish to turn off saving undo information if you use the Scintilla to store text
generated by a program (a Log view) or in a display window where text is often deleted and
regenerated.
}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetUndoCollection)
{See <%LINK SetUndoCollection%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.BeginUndoAction)
{Marks the beginning of a set of operations that you want to undo all as one operation but
that you have to generate as several operations.
Alternatively, you can use these to mark a set of operations that you do not want to have
combined with the preceding or following operations if they are undone.<%SEEALSO EndUndoAction%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.EndUndoAction)
{Marks the end of a set of operations that you want to undo all as one operation but
that you have to generate as several operations.
Alternatively, you can use these to mark a set of operations that you do not want to have
combined with the preceding or following operations if they are undone.<%SEEALSO BeginUndoAction%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetLineCount)
{This returns the number of lines in the document. An empty document contains 1 line. A document holding only an end of line sequence has 2 lines.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetFirstVisibleLine)
{This returns the line number of the first visible line in the Scintilla view. The first line in the document is numbered 0.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.LinesOnScreen)
{This returns the number of complete lines visible on the screen. With a constant line height, this is the vertical space available divided by the line separation. Unless you arrange to size your window to an integral number of lines, there may be a partial line visible at the bottom of the view.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetCurLine)
{This retrieves the text of the line containing the caret and returns the position within the line of the caret. Pass in char* text pointing at a buffer large enough to hold the text you wish to retrieve and a terminating 0 character. Set textLen to the length of the buffer. If the text argument is 0 then the length that should be allocated to store the entire current line is returned.<%SEEALSO GetSelText,GetLine,GetText,GetStyledText,GetTextRange%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SelectionIsRectangle)
{This returns 1 if the current selection is in rectangle mode, 0 if not.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetSelectionMode)
{Set the selection mode, which can be stream (SC_SEL_STREAM=1) or rectangular (SC_SEL_RECTANGLE=2) or by lines (SC_SEL_LINES=3).
When set in these modes, regular caret moves will extend or reduce the selection,
until the mode is cancelled by a call with same value or with <%LINK Cancel%>.<%SEEALSO GetSelectionMode%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetSelectionMode)
{
Get the selection mode, which can be stream (SC_SEL_STREAM=1) or rectangular (SC_SEL_RECTANGLE=2) or by lines (SC_SEL_LINES=3).
When set in these modes, regular caret moves will extend or reduce the selection,
until the mode is cancelled by a call with same value or with <%LINK Cancel%>.

<%RETURNS%>Returns the current mode even if the selection was made by mouse or with regular extended moves.<%SEEALSO SetSelectionMode%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.Cancel)
{Returns the selectionmode to the default.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetSelStartPosition)
{Retrieve the position of the start of the selection at the given line with INVALID_POSITION returned if no selection on this line.<%SEEALSO GetSelEndPosition%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetSelEndPosition)
{Retrieve the position of the end of the selection at the given line with INVALID_POSITION returned if no selection on this line.<%SEEALSO GetSelStartPosition%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.MoveCaretInsideView)
{If the caret is off the top or bottom of the view, it is moved to the nearest line that is visible to its current position. Any selection is lost.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.PositionBefore)
{Returns the position before another position in the document taking into account the current code page. The minimum position returned is 0 and the maximum is the last position in the document. If called with a position within a multi byte character will return the position of the start of that character.<%SEEALSO PositionAfter%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.PositionAfter)
{Returns the position after another position in the document taking into account the current code page. The minimum position returned is 0 and the maximum is the last position in the document. If called with a position within a multi byte character will return the position of the end of that character.<%SEEALSO PositionBefore%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.TextWidth)
{This returns the pixel width of a string drawn in the given 'styleNumber' which can be used, for example, to decide how wide to make the line number margin in order to display a given number of numerals.<%SEEALSO TextHeight%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.TextHeight)
{This returns the height in pixels of a particular line. Currently all lines are the same height.<%SEEALSO TextWidth%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetColumn)
{This message returns the column number of a position pos within the document taking the width of tabs into account. This returns the column number of the last tab on the line before pos, plus the number of characters between the last tab and pos. If there are no tab characters on the line, the return value is the number of characters up to the position on the line. In both cases, double byte characters count as a single character. This is probably only useful with monospaced fonts.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.ChooseCaretX)
{Scintilla remembers the x value of the last position horizontally moved to explicitly by the user and this value is then used when moving vertically such as by using the up and down keys. This message sets the current x position of the caret as the remembered value.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.LineScroll)
{This will attempt to scroll the display by the number of columns and lines that you specify. Positive line values increase the line number at the top of the screen (i.e. they move the text upwards as far as the user is concerned), Negative line values do the reverse.

The column measure is the width of a space in the default style. Positive values increase the column at the left edge of the view (i.e. they move the text leftwards as far as the user is concerned). Negative values do the reverse.<%LINK SetXOffset%>
}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.ScrollCaret)
{If the current position (this is the caret if there is no selection) is not visible, the view is scrolled to make it visible according to the current caret policy.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetXCaretPolicy)
{These set the caret policy. The value of caretPolicy is a combination of CARET_SLOP, CARET_STRICT, CARET_JUMPS and CARET_EVEN.

<%BOLD%>CARET_SLOP<%TEXT%>
If set, we can define a slop value: caretSlop. This value defines an unwanted zone (UZ) where the caret is... unwanted. This zone is defined as a number of pixels near the vertical margins, and as a number of lines near the horizontal margins. By keeping the caret away from the edges, it is seen within its context. This makes it likely that the identifier that the caret is on can be completely seen, and that the current line is seen with some of the lines following it, which are often dependent on that line.

<%BOLD%>CARET_STRICT<%TEXT%>
If set, the policy set by CARET_SLOP is enforced... strictly. The caret is centred on the display if caretSlop is not set, and cannot go in the UZ if caretSlop is set.
<%BOLD%>CARET_JUMPS<%TEXT%>
If set, the display is moved more energetically so the caret can move in the same direction longer before the policy is applied again. '3UZ' notation is used to indicate three time the size of the UZ as a distance to the margin.
<%BOLD%>CARET_EVEN<%TEXT%>
If not set, instead of having symmetrical UZs, the left and bottom UZs are extended up to right and top UZs respectively. This way, we favour the displaying of useful information: the beginning of lines, where most code reside, and the lines after the caret, for example, the body of a function.<%SEEALSO SetYCaretPolicy%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetYCaretPolicy)
{See <%LINK SetXCaretPolicy%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetVisiblePolicy)
{This determines how the vertical positioning is determined when <%LINK EnsureVisibleEnforcePolicy%> is called. It takes VISIBLE_SLOP and VISIBLE_STRICT flags for the policy parameter. It is similar in operation to <%LINK SetYCaretPolicy%>(int caretPolicy, int caretSlop).}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetXOffset)
{The 'xOffset' is the horizontal scroll position in pixels of the start of the text view. A value of 0 is the normal position with the first text column visible at the left of the view.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetXOffset)
{See <%LINK SetXOffset%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetCursor)
{The cursor is normally chosen in a context sensitive way, so it will be different over the margin than when over the text. When performing a slow action, you may wish to change to a wait cursor. You set the cursor type with SCI_SETCURSOR. The curType argument can be:

SC_CURSORNORMAL -1	The normal cursor is displayed.
SC_CURSORWAIT   4	  The wait cursor is displayed when the mouse is over or owned by the Scintilla
                    window.

Cursor values 1 through 7 have defined cursors, but only SC_CURSORWAIT is usefully controllable. Other values of curType cause a pointer to be displayed. The <%LINK GetCursor%> method returns the last cursor type you set, or SC_CURSORNORMAL (-1) if you have not set a cursor type.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetCursor)
{See <%LINK SetCursor%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetMouseDownCaptures)
{When the mouse is pressed inside Scintilla, it is captured so future mouse movement events are sent to Scintilla.
Set 'captures' to false to turn off.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetMouseDownCaptures)
{<%LINK SetMouseDownCaptures%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.ConvertEOLs)
{This message changes all the end of line characters in the document to match eolMode. Valid values are: SC_EOL_CRLF (0), SC_EOL_CR (1), or SC_EOL_LF (2).}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetViewEOL)
{Normally, the end of line characters are hidden, but SCI_SETVIEWEOL allows you to display (or hide) them by setting visible true (or false). The visible rendering of the end of line characters is similar to (CR), (LF), or (CR)(LF).}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetViewEOL)
{Returns wether end of line is visible.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetOvertype)
{When overtype is enabled, each typed character replaces the character to the right of the text caret.
When overtype is disabled, characters are inserted at the caret.<%SEEALSO GetOvertype%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetOvertype)
{returns True if overtyping is active, otherwise False will be returned.<%SEEALSO SetOvertype%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.Cut)
{Copies the selected text to the clipboard and clear it from the document.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.Copy)
{Copies the selected text to the clipboard.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.Paste)
{Insert the text from the clipboard into the document.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.CanPaste)
{Returns True if there are something to be pasted from the clipboard.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.Clear)
{Erase the selected text from the document}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.FindTextX)
{Search for text.

Several of the search routines use flag options, which include a simple regular expression search. Combine the flag options by adding them:
Symbol               Effect
SCFIND_MATCHCASE     A match only occurs with text that matches the case of the search string.
SCFIND_WHOLEWORD     A match only occurs if the characters before and after are not word characters.
SCFIND_WORDSTART     A match only occurs if the character before is not a word character.
SCFIND_REGEXP        The search string should be interpreted as a regular expression.
SCFIND_POSIX         Treat regular expression in a more POSIX compatible manner by interpreting bare ( and ) for tagged sections rather than \( and \).

If SCFIND_REGEXP is not included in the searchFlags, you can search backwards to find the previous occurrence of a search string by setting the end of the search range before the start. If SCFIND_REGEXP is included, searches are always from a lower position to a higher position, even if the search range is backwards.

<%NOTE%> Originally named FindText, but clashed with the
FindText macros under C++ Builder.<%SEEALSO TScintillaBase.SearchInTarget%>
}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetControlCharSymbol)
{By default, Scintilla displays control characters (characters with codes less than 32) in a rounded rectangle as ASCII mnemonics: "NUL", "SOH", "STX", "ETX", "EOT", "ENQ", "ACK", "BEL", "BS", "HT", "LF", "VT", "FF", "CR", "SO", "SI", "DLE", "DC1", "DC2", "DC3", "DC4", "NAK", "SYN", "ETB", "CAN", "EM", "SUB", "ESC", "FS", "GS", "RS", "US". These mnemonics come from the early days of signaling, though some are still used (LF = Line Feed, BS = Back Space, CR = Carriage Return, for example).

You can choose to replace these mnemonics by a nominated symbol with an ASCII code in the range 32 to 255. If you set a symbol value less than 32, all control characters are displayed as mnemonics. The symbol you set is rendered in the font of the style set for the character. You can read back the current symbol with the <%LINK GetControlCharSymbol%>. The default symbol value is 0.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetControlCharSymbol)
{See <%LINK SetControlCharSymbol%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetLength)
{Return the length of the document in characters.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetTextLength)
{Return the length of the document in characters.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetModify)
{This returns non-zero if the document is modified and 0 if it is unmodified. The modified status of a document is determined by the undo position relative to the save point. The save point is set by <%LINK SetSavePoint%>, usually when you have saved data to a file.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetSelectionStart)
{These set the selection based on the assumption that the anchor position is less than the current position.
They do not make the caret visible.

<%SEEALSO ScrollCaret%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetSelectionEnd)
{See <%LINK SetSelectionStart%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetSelectionStart)
{These return the start and end of the selection without regard to which end is the current position and which is the anchor. <%LINK GetSelectionStart%> returns the smaller of the current position or the anchor position. <%LINK GetSelectionEnd%> returns the larger of the two values.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetSelectionEnd)
{See <%LINK GetSelectionStart%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.WordStartPosition)
{These methods return the start and end of words using the same definition of words as used internally within Scintilla. You can set your own list of characters that count as words with <%LINK SetWordChars%>. The position sets the start or the search, which is forwards when searching for the end and backwards when searching for the start.

Set 'onlyWordCharacters' to True to stop searching at the first non-word character in the search direction. If 'onlyWordCharacters' is False, the first character in the search direction sets the type of the search as word or non-word and the search stops at the first non-matching character. Searches are also terminated by the start or end of the document.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.WordEndPosition)
{See <%LINK WordStartPosition%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.PositionFromPoint)
{Finds the closest character position to a point.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.PositionFromPointClose)
{Finds the closest character position to a point.
If outside the window or not close to any characters return -1.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.PointXFromPosition)
{return the x display pixel location of text at position 'pos' in the document.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.PointYFromPosition)
{return the y display pixel location of text at position 'pos' in the document.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.HideSelection)
{The normal state is to make the selection visible by drawing it as set by <%LINK SetSelFore%> and <%LINK SetSelBack%>. However, if you hide the selection, it is drawn as normal text.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetWhitespaceFore)
{By default, the colour of visible white space is determined by the lexer in use.
The foreground and/or background colour of all visible white space can be set globally, overriding the lexer's colours with this method and <%LINK SetWhitespaceBack%>.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetWhitespaceBack)
{By default, the colour of visible white space is determined by the lexer in use.
The foreground and/or background colour of all visible white space can be set globally, overriding the lexer's colours with this method and <%LINK SetWhitespaceFore%>.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetEndStyled)
{Scintilla keeps a record of the last character that is likely to be styled correctly.
This is moved forwards when characters after it are styled and moved backwards if changes
are made to the text of the document before it.

Before drawing text, this position is checked to see if any styling is needed and, if so,
a <%LINK OnStyleNeeded%> event is fired. The container can send GetEndStyled to work out
where it needs to start styling. Scintilla will always ask to style whole lines.
<%SEEALSO StartStyling,SetStyling,SetStylingEx,SetLineState,GetLineState,GetMaxLineState%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.StartStyling)
{his prepares for styling by setting the styling position pos to start at and a mask indicating which bits of the style bytes can be set. The mask allows styling to occur over several passes, with, for example, basic styling done on an initial pass to ensure that the text of the code is seen quickly and correctly, and then a second slower pass, detecting syntax errors and using indicators to show where these are. For example, with the standard settings of 5 style bits and 3 indicator bits, you would use a mask value of 31 (0x1f) if you were setting text styles and did not want to change the indicators. After StartStyling,
call <%LINK SetStyling%> for each lexical entity to style.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetStyling)
{This message sets the style of length characters starting at the styling position and then increases the styling position by length, ready for the next call. If 'sCell' is the style byte, the operation is:
if ((sCell and mask) <> style) sCell = (sCell and (not mask)) or ((style and mask)<>0);}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetStylingEx)
{As an alternative to <%LINK SetStyling%>, which applies the same style to each byte, you can use this message which specifies the styles for each of 'length' bytes from the styling position and then increases the styling position by 'length', ready for the next call. The 'length' styling bytes pointed at by 'styles' should not contain any bits not set in mask.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetLineState)
{As well as the 8 bits of lexical state stored for each character there is also an integer stored for each line. This can be used for longer lived parse states such as what the current scripting language is in an ASP page. Use this to set the integer value.<%SEEALSO GetLineState%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetLineState)
{As well as the 8 bits of lexical state stored for each character there is also an integer stored for each line. This can be used for longer lived parse states such as what the current scripting language is in an ASP page. Use this to get the integer value.<%SEEALSO GetLineState%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetMaxLineState)
{This returns the last line that has any line state.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.StyleResetDefault)
{This message resets STYLE_DEFAULT(32) to its state when Scintilla was initialised.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetSelFore)
{You can choose to override the default selection colouring with these two messages. The colour you provide is used if you set useSelection*Colour to true. If it is set to false, the default colour colouring is used and the 'colour' argument has no effect.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetSelBack)
{See <%LINK SetSelFore%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetCaretFore)
{Set the color of the caret.<%SEEALSO GetCaretFore%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetCaretFore)
{Get the color of the caret.<%SEEALSO SetCaretFore%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetCharsDefault)
{Use the default sets of word and whitespace characters. This sets whitespace to space, tab and other characters with codes less than 0x20, with word characters set to alphanumeric and '_'.<%SEEALSO SetWhitespaceChars,SetWordChars%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetWhitespaceChars)
{Similar to <%LINK SetWordChars%>, this however allows the user to define which chars Scintilla considers as whitespace. Setting the whitespace chars allows the user to fine-tune Scintilla's behaviour doing such things as moving the cursor to the start or end of a word; for example, by defining punctuation chars as whitespace, they will be skipped over when the user presses Ctrl+Left or Ctrl+Right. This function should be called after <%LINK SetWordChars%> as it will reset the whitespace characters to the default set.<%SEEALSO SetWordChars,SetCharsDefault%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetWordChars)
{Scintilla has several functions that operate on words, which are defined to be contiguous sequences of characters from a particular set of characters. This message defines which characters are members of that set. The character sets are set to default values before processing this function. For example, if you don't allow '_' in your set of characters use:
SetWordChars(0, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789");<%SEEALSO SetWhitespaceChars,SetCharsDefault%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.BraceHighlight)
{Up to two characters can be highlighted in a 'brace highlighting style', which is defined as style number STYLE_BRACELIGHT (34).
If you have enabled indent guides, you may also wish to highlight the indent that corresponds with the brace.
You can locate the column with <%LINK GetColumn%> and highlight the indent with <%LINK SetHighlightGuide%>.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.BraceBadLight)
{If there is no matching brace then the brace badlighting style, style BRACE_BADLIGHT (35), can be used to show the brace that is unmatched. Using a position of INVALID_POSITION (-1) removes the highlight.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.BraceMatch)
{Finds a corresponding matching brace given 'pos', the position of one brace. The brace characters handled are '(', ')', '[', ']', '{', '}', '<', and '>'. The search is forwards from an opening brace and backwards from a closing brace.
If the character at position is not a brace character, or a matching brace cannot be found, the return value is -1. Otherwise, the return value is the position of the matching brace.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetLineIndentPosition)
{This returns the position at the end of indentation of a line.<%SEEALSO SetLineIndentation%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetLineIndentation)
{The amount of indentation on a line can be discovered and set with SetLineIndentation and <%LINK GetLineIndentation%>. The indentation is measured in character columns, which correspond to the width of space characters.<%SEEALSO GetLineIndentation%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetLineIndentation)
{See <%LINK SetLineIndentation%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.IndicSetStyle)
{Set and get the style for a particular indicator. 

The default indicator styles are equivalent to:
IndicSetStyle(0, INDIC_SQUIGGLE);
IndicSetStyle(1, INDIC_TT);
IndicSetStyle(2, INDIC_PLAIN);

By default, Scintilla organizes the style byte associated with each text byte as 5 bits of style information (for 32 styles) and 3 bits of indicator information for 3 independent indicators so that, for example, syntax errors, deprecated names and bad indentation could all be displayed at once. Indicators may be displayed as simple underlines, squiggly underlines, a line of small 'T' shapes, a line of diagonal hatching, a strike-out or a rectangle around the text.

The indicators are set using <%LINK StartStyling%> with a INDICS_MASK mask and <%LINK SetStyling%> with the values INDIC0_MASK, INDIC1_MASK and INDIC2_MASK.

The number of bits used for styles can be altered with <%LINK SetStyleBits%> from 0 to 7 bits. The remaining bits can be used for indicators, so there can be from 1 to 8 indicators. However, the INDIC*_MASK constants defined in Scintilla.h all assume 5 bits of styling information and 3 indicators. If you use a different arrangement, you must define your own constants.

These methods allow you to get and set the visual appearance of the indicators. They all use an 'indicatorNumber' argument in the range 0 to 7 to set the indicator to style. With the default settings, only indicators 0, 1 and 2 will have any visible effect.<%SEEALSO IndicSetFore,IndicGetFore%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.IndicGetStyle)
{See <%LINK IndicSetStyle%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.IndicSetFore)
{Set the foreground color for the indicator 'indicatorNumber'.<%SEEALSO IndicSetStyle,IndicGetFore%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.IndicGetFore)
{Get the foreground color for the indicator 'indicatorNumber'.<%SEEALSO IndicSetStyle,IndicSetFore%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetDocPointer)
{This returns a pointer to the document currently in use by the window. It has no other effect.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetDocPointer)
{See Scintilla Documentation.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.CreateDocument)
{This message creates a new, empty document and returns a pointer to it. This document is not selected into the editor and starts with a reference count of 1. This means that you have ownership of it and must either reduce its reference count by 1 after using <%LINK SetDocPointer%> so that the Scintilla window owns it or you must make sure that you reduce the reference count by 1 with <%LINK TScintillaBase.ReleaseDocument,ReleaseDocument%> before you close the application to avoid memory leaks.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.AddRefDocument)
{This increases the reference count of a document by 1. If you want to replace the current document in the Scintilla window and take ownership of the current document, for example if you are editing many documents in one window, do the following:
1. Use <%LINK GetDocPointer%> to get a pointer to the document, pDoc.
2. Use AddRefDocument(0, pDoc) to increment the reference count.
3. <%LINK SetDocPointer%>(0, pNewDoc) to set a different document or <%LINK SetDocPointer%>(0, 0) to set a new, empty document.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.ReleaseDocument)
{Reduces the reference count of the document identified by 'pDoc'. 'pDoc' must be the result of <%LINK GetDocPointer%> or <%LINK CreateDocument%> and must point at a document that still exists. If you call this on a document with a reference count of 1 that is still attached to a Scintilla window, bad things will happen. To keep the world spinning in its orbit you must balance each call to <%LINK CreateDocument%> or <%LINK AddRefDocument%> with a call to ReleaseDocument.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.VisibleFromDocLine)
{When some lines are folded, then a particular line in the document may
be displayed at a different position to its document position.

If no lines are folded, this message returns 'docLine'.
Otherwise, this returns the display line (counting the very first visible line as 0).
The display line of an invisible line is the same as the previous visible line.
The display line number of the first line in the document is 0.
If there is folding and docLine is outside the range of lines in the document,
the return value is -1. Lines can occupy more than one display line if they wrap.<%SEEALSO DocLineFromVisible%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.DocLineFromVisible)
{When some lines are hidden, then a particular line in the document may
be displayed at a different position to its document position.

Returns the document line number that corresponds to a display line
(counting the display line of the first line in the document as 0).
If 'displayLine' is less than or equal to 0, the result is 0.
If 'displayLine' is greater than or equal to the number of displayed lines,
the result is the number of lines in the document.<%SEEALSO VisibleFromDocLine%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.ShowLines)
{mark a range of lines as visible and then redraw the display.<%SEEALSO HideLines,GetLineVisible%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.HideLines)
{mark a range of lines as invisible and then redraw the display.<%SEEALSO ShowLines,GetLineVisible%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetLineVisible)
{Returns the visible state of a line and returns True if it is visible and False if it is not visible.<%SEEALSO HideLines,ShowLines%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetFoldLevel)
{Set a 32-bit value that contains the fold level of a line and some flags associated with folding.
The fold level is a number in the range 0 to SC_FOLDLEVELNUMBERMASK (4095).
However, the initial fold level is set to SC_FOLDLEVELBASE (1024) to allow unsigned arithmetic on folding levels.
There are two addition flag bits. SC_FOLDLEVELWHITEFLAG indicates that the line is blank and allows it to be treated slightly different then its level may indicate.
For example, blank lines should generally not be fold points. SC_FOLDLEVELHEADERFLAG indicates that the line is a header (fold point).

For instance, to set the level to 'thisLevel' and mark a line as being a fold point use:
SetFoldLevel(line, thisLevel | SC_FOLDLEVELHEADERFLAG).<%SEEALSO GetFoldLevel,SetFoldFlags%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetFoldLevel)
{Get a 32-bit value that contains the fold level of a line and some flags associated with folding.
The fold level is a number in the range 0 to SC_FOLDLEVELNUMBERMASK (4095).
However, the initial fold level is set to SC_FOLDLEVELBASE (1024) to allow unsigned arithmetic on folding levels.
There are two addition flag bits. SC_FOLDLEVELWHITEFLAG indicates that the line is blank and allows it to be treated slightly different then its level may indicate.
For example, blank lines should generally not be fold points. SC_FOLDLEVELHEADERFLAG indicates that the line is a header (fold point).

Use GetFoldLevel(line) & SC_FOLDLEVELNUMBERMASK to get the fold level of a line.
Likewise, use SCI_GETFOLDLEVEL(line) & SC_FOLDLEVEL*FLAG to get the state of the flags.
To set the fold level you must or in the associated flags.<%SEEALSO SetFoldLevel,SetFoldFlags%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetFoldFlags)
{In addition to showing markers in the folding margin, you can indicate folds to the user
by drawing lines in the text area.
The lines are drawn in the foreground colour set for STYLE_DEFAULT (32).

See Scintilla Documentation for more info.


<%NOTE%>This message causes the display to redraw.<%SEEALSO GetFoldLevel,SetFoldLevel%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetLastChild)
{Searches for the next line after 'startLine', that has a folding level that is less
than or equal to 'level' and then returns the previous line number.

If you set 'level' to -1, level is set to the folding level of line 'startLine'.
If from is a fold point, GetLastChild(from, -1) returns the last line that would be
in made visible or hidden by toggling the fold state.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetFoldParent)
{Returns the line number of the first line before 'startLine' that is marked as a fold point
with SC_FOLDLEVELHEADERFLAG and has a fold level less than the 'startLine'.
If no line is found, or if the header flags and fold levels are inconsistent, the return value is -1.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.ToggleFold)
{Each fold point may be either expanded, displaying all its child lines, or contracted, hiding all the child lines.

This method toggles the folding state of the given line as long as it has the SC_FOLDLEVELHEADERFLAG set.
This method takes care of folding or expanding all the lines that depend on the line.

<%NOTE%>The display updates after this message.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetFoldExpanded)
{Set the expanded state of a single line.

It has no effect on the visible state of the line or any lines that depend on it.
It does change the markers in the folding margin.<%SEEALSO GetFoldExpanded%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetFoldExpanded)
{Get the expanded state of a single line.

If you ask for the expansion state of a line that is outside the document, the result is False.<%SEEALSO SetFoldExpanded%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.EnsureVisible)
{A line may be hidden because more than one of its parent lines is contracted.
This method travels up the fold hierarchy, expanding any contracted folds until
they reach the top level. The line will then be visible.<%SEEALSO EnsureVisibleEnforcePolicy%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.EnsureVisibleEnforcePolicy)
{A line may be hidden because more than one of its parent lines is contracted.
This method travels up the fold hierarchy, expanding any contracted folds until
they reach the top level. The line will then be visible.
The vertical caret policy set by <%LINK SetVisiblePolicy%> is then applied.<%SEEALSO EnsureVisible%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.LinesSplit)
{Split a range of lines indicated by the target into lines that are at most 'pixelWidth' wide.
Splitting occurs on word boundaries wherever possible in a similar manner to line wrapping.
When 'pixelWidth' is 0 then the width of the window is used.<%SEEALSO LinesJoin%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.LinesJoin)
{Join a range of lines indicated by the target into one line by removing line end characters. Where this would lead to no space between words, an extra space is inserted.<%SEEALSO LinesSplit%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.ZoomIn)
{Increases the zoom factor by one point if the current zoom factor is less than 20 points.<%SEEALSO ZoomOut%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.ZoomOut)
{Decreases the zoom factor by one point if the current zoom factor is greater than -10 points.<%SEEALSO ZoomIn%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetZoom)
{Set the zoom factor directly.

There is no limit set on the factors you can set, so limiting yourself to -10 to +20 to match the incremental zoom functions is a good idea.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetZoom)
{Returns the current Zoom factor.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetLexer)
{You can select the lexer to use with an integer code from the SCLEX_* enumeration in
Scintilla.h (found in the Scintilla project http://www.scintilla.org)

There are two codes in this sequence that do not use lexers:
SCLEX_NULL to select no lexing action and SCLEX_CONTAINER which sends the SCN_STYLENEEDED notification
to the container whenever a range of text needs to be styled.

You cannot use the SCLEX_AUTOMATIC value; this identifies additional external lexers that
Scintilla assigns unused lexer numbers to.}
//CE_Desc_End

//CE_Desc_Begin(TScintillaBase.GetLexer)
{Returns the current lexer.

It is one integer code from the SCLEX_* enumeration in Scintilla.h (found in the Scintilla project http://www.scintilla.org)
}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetLexerLanguage)
{Select a lexer by name, and is the only method if you are using an external lexer or
if you have written a lexer module for a language of your own and do not wish to assign it an explicit lexer number.

To select an existing lexer, set name to match the (case sensitive) name given to the module,
for example "ada" or "python", not "Ada" or "Python".

To locate the name for the built-in lexers, open the relevant Lex*.cxx file (in the Scintilla Project) and search for
LexerModule. The third argument in the LexerModule constructor is the name to use.

To test if your lexer assignment worked, use <%LINK GetLexer%> before and after setting the new lexer to see if the lexer number changed.
}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.LoadLexerLibrary)
{Load a lexer implemented in a shared library. This is a .DLL file.

Per version 1.62 these are the function names used:
<%BOLD%>GetLexerCount<%TEXT%>

int EXT_LEXER_DECL GetLexerCount();

<%RETURNS%>The count of lexers in the library.

<%BOLD%>GetLexerName<%TEXT%>

void EXT_LEXER_DECL GetLexerName(unsigned int Index, char *name, int buflength);



<%BOLD%>Lex<%TEXT%>

void EXT_LEXER_DECL Lex(unsigned int lexer, unsigned int startPos, int length, int initStyle,
                  char *words[], WindowID window, char *props);

<%BOLD%>Fold<%TEXT%>
void EXT_LEXER_DECL Fold(unsigned int lexer, unsigned int startPos, int length, int initStyle,
                  char *words[], WindowID window, char *props);

<%BOLD%>GetLexerFunction<%TEXT%>

This function/type doesn's seem to be used just yet.

typedef void* (EXT_LEXER_DECL *GetLexerFunction)(unsigned int Index);
}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.Colourise)
{This forces the current lexer or the container (if the lexer is set to SCLEX_CONTAINER) to
style the document between 'startPos' and 'endPos'.

If endPos is -1, the document is styled from startPos to the end.

If the "fold" property is set to "1" and your lexer or container supports folding,
fold levels are also set.

<%NOTE%>This message causes a redraw.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetProperty)
{You can communicate settings to lexers with keyword:value string pairs.
There is no limit to the number of keyword pairs you can set, other than available memory.
'key' is a case sensitive keyword, 'value' is a string that is associated with the keyword.
If there is already a value string associated with the keyword, it is replaced.
If you pass a zero length string, the method does nothing.

Both 'key' and 'value' are used without modification; extra spaces at the beginning or end
of key are significant.

The value string can refer to other keywords. For example, SetProperty('foldTimes10', '$(fold)0')
stores the string '$(fold)0', but when this is accessed, the $(fold) is replaced by the value of
the "fold" keyword (or by nothing if this keyword does not exist).

Currently the "fold" property is defined for most of the lexers to set the fold structure if set to "1".
(python) SCLEX_PYTHON understands "tab.timmy.whinge.level" as a setting that determines how to indicate
bad indentation.

Most keywords have values that are interpreted as integers.
Search the lexer sources for GetPropertyInt to see how properties are used.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetKeywords)
{You can set up to 9 lists of keywords for use by the current lexer.
'keyWordSet' can be 0 to 8 (actually 0 to KEYWORDSET_MAX) and selects which keyword list to replace.
'keyWordList' is a list of keywords separated by spaces, tabs, "\n" or "\r" or any combination of these. It is expected that the keywords will be composed of standard ASCII printing characters, but there is nothing to stop you using any non-separator character codes from 1 to 255 (except common sense).

How these keywords are used is entirely up to the lexer.

Some languages, such as HTML may contain embedded languages, VBScript and JavaScript are common for HTML.
For HTML, key word set 0 is for HTML, 1 is for JavaScript and 2 is for VBScript, 3 is for Python,
4 is for PHP and 5 is for SGML and DTD keywords.

Review the lexer code to see examples of keyword list.

A fully conforming lexer sets the fourth argument of the LexerModule constructor
to be a list of strings that describe the uses of the keyword lists.

Alternatively, you might use set 0 for general keywords, set 1 for keywords that cause indentation and set 2 for keywords that cause unindentation. Yet again, you might have a simple lexer that colours keywords and you could change languages by changing the keywords in set 0. There is nothing to stop you building your own keyword lists into the lexer, but this means that the lexer must be rebuilt if more keywords are added.

<%NOTE%>
It seems that if you start a keyword with a ^, then the keyword is treated as a prefix.
i.e if you define ^WIN as a keyword, then WINWHATEVER will also be treated as a keyword.
}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.UsePopUp)
{Clicking the wrong button on the mouse pops up a short default editing menu.

This may be turned off with UsePopUp(False).

If you turn it off, context menu commands (in Windows, WM_CONTEXTMENU) will not be
handled by Scintilla, so the parent of the Scintilla window will have the opportunity
to handle the message.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.StartRecord)
{Start Macro Recording<%SEEALSO TScintillaBase.OnMacroRecord,StopRecord%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.StopRecord)
{Start Macro Recording<%SEEALSO OnMacroRecord,StartRecord%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.CallTipShow)
{Starts the process by displaying the call tip window. If a call tip is already active, this has no effect.
'posStart' is the position in the document at which to align the call tip. The call tip text is aligned to start 1 line below this character.
'definition' is the call tip text. This can contain multiple lines separated by '\n' (Line Feed, ASCII code 10) characters.

<%BOLD%>CALLTIPS<%TEXT%>
Call tips are small windows displaying the arguments to a function and are displayed after
the user has typed the name of the function.
There is some interaction between call tips and autocompletion lists in that showing a calltip
cancels any active autocompletion list, and vice versa.

Call tips can highlight part of the text within them.
You could use this to highlight the current argument to a function by counting the number of commas
(or whatever separator your language uses).
See SciTEBase::CharAdded() in SciTEBase.cxx for an example of call tip use.

The mouse may be clicked on call tips and this causes a <%LINK TScintillaBase.OnCallTipClick%> event to be sent to the container.
Small up an down arrows may be displayed within a call tip by, respectively, including the characters '\001', or '\002'.
This is useful for showing that there are overloaded variants of one function name and that the user can click on the arrows
to cycle through the overloads.

Alternatively, call tips can be displayed when you leave the mouse pointer for a while over a word in response to the SCN_DWELLSTART notification and cancelled in response to SCN_DWELLEND. This method could be used in a debugger to give the value of a variable, or during editing to give information about the word under the pointer.<%SEEALSO CallTipCancel%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.CallTipCancel)
{Cancels any displayed call tip. Scintilla will also cancel call tips for you if you use any keyboard commands that are not compatible with editing the argument list of a function.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.CallTipActive)
{This returns True if a call tip is active and False if it is not active.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.CallTipPosStart)
{Returns the value of the current position when <%LINK CallTipShow%> started to display the tip.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.CallTipSetHlt)
{This sets the region of the call tips text to display in a highlighted style.
'hlStart' is the zero-based index into the string of the first character to highlight
and 'hlEnd' is the index of the first character after the highlight.
'hlEnd' must be greater than 'hlStart'; hlEnd-hlStart is the number of characters to highlight.
Highlights can extend over line ends if this is required.

Unhighlighted text is drawn in a mid gray. Selected text is drawn in a dark blue.
The background is white. These can be changed with <%LINK CallTipSetBack%>, <%LINK CallTipSetFore%>, and <%LINK CallTipSetForeHlt%>.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.CallTipSetBack)
{The background colour of call tips can be set with this method; the default colour is white.
It is not a good idea to set a dark colour as the background as the unselected text is drawn
in mid gray and the selected text in a dark blue.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.CallTipSetFore)
{The colour of call tip text can be set with this message; the default colour is mid gray.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.CallTipSetForeHlt)
{The colour of highlighted call tip text can be set with this message; the default colour is dark blue.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.UserListShow)
{The 'listType' parameter is returned to the container as 'listType' parameter in a <%LINK OnUserListSelection%> event.

It must be greater than 0 as this is how Scintilla tells the difference between
an autocompletion list and a user list. If you have different types of list,
for example a list of buffers and a list of macros, you can use 'listType' to tell which
one has returned a selection.

<%BOLD%>USERLISTS<%TEXT%>
User lists use the same internal mechanisms as autocompletion lists, and all the calls listed for autocompletion work on them; you cannot display a user list at the same time as an autocompletion list is active. They differ in the following respects:

o The AutoCGetChooseSingle method has no effect.
o When the user makes a selection you are sent a <%LINK OnUserListSelection%> event.

BEWARE: if you have set fillup characters or stop characters, these will still be active with the user list, and may result in items being selected or the user list cancelled due to the user typing into the editor.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.AutoCShow)
{Causes a list to be displayed.

'lenEntered' is the number of characters of the word already entered and list is the list of words separated by separator characters.
The initial separator character is a space but this can be set or got with <%LINK AutoCSetSeparator%> and <%LINK AutoCGetSeparator%>.

The list of words should be in sorted order. If set to ignore case mode with <%LINK AutoCSetIgnoreCase%>, then strings are matched after being converted to upper case. One result of this is that the list should be sorted with the punctuation characters '[', '\', ']', '^', '_', and '`' sorted after letters.

<%BOLD%>AUTOCOMPLETION<%TEXT%>
Autocompletion displays a list box showing likely identifiers based upon the users typing. The user chooses the currently selected item by pressing the tab character or another character that is a member of the fillup character set defined with <%LINK AutoCSetFillups%>. Autocompletion is triggered by your application. For example, in C if you detect that the user has just typed fred. you could look up fred, and if it has a known list of members, you could offer them in an autocompletion list. Alternatively, you could monitor the user's typing and offer a list of likely items once their typing has narrowed down the choice to a reasonable list. As yet another alternative, you could define a key code to activate the list.

To make use of autocompletion you must monitor each character added to the document. See SciTEBase::CharAdded() in SciTEBase.cxx for an example of autocompletion.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.AutoCCancel)
{Cancels any displayed autocompletion list.

When in autocompletion mode, the list should disappear when the user types a character that can not be part of the autocompletion, such as '.', '(' or '[' when typing an identifier.
A set of characters that will cancel autocompletion can be specified with <%LINK AutoCStops%>.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.AutoCActive)
{Returns non-zero if there is an active autocompletion list and zero if there is not.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.AutoCPosStart)
{Returns the value of the current position when <%LINK AutoCShow%> started display of the list.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.AutoCComplete)
{Triggers autocompletion. This has the same effect as the tab key.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.AutoCStops)
{The 'chars' argument is a string containing a list of characters that will automatically cancel the autocompletion list. When you start the editor, this list is empty.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.AutoCSetSeparator)
{Set the separator character used to separate words in the <%LINK AutoCShow%> list. The default is the space character.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.AutoCGetSeparator)
{Get the separator character used to separate words in the <%LINK AutoCShow%> list. The default is the space character.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.AutoCSelect)
{Selects an item in the autocompletion list.
It searches the list of words for the first that matches 'select'. By default, comparisons are case sensitive, but you can change this with <%LINK AutoCSetIgnoreCase%>. The match is character by character for the length of the select string. That is, if select is "Fred" it will match "Frederick" if this is the first item in the list that begins with "Fred". If an item is found, it is selected. If the item is not found, the autocompletion list closes if auto-hide is true (see <%LINK AutoCSetAutoHide%>).
The current selection can be retrieved with <%LINK AutoCGetCurrent%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.AutoCGetCurrent)
{Returns the current selection in the autocompletelist.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.AutoCSetCancelAtStart)
{The default behavior is for the list to be cancelled if the caret moves before the location it was at when the list was displayed.

By calling this method with a False argument, the list is not cancelled until the caret moves before the first character of the word being completed.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.AutoCGetCancelAtStart)
{See <%LINK AutoCSetCancelAtStart%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.AutoCSetFillups)
{If a fillup character is typed with an autocompletion list active, the currently selected item in the list is added into the document, then the fillup character is added. Common fillup characters are '(', '[' and '.' but others are possible depending on the language. By default, no fillup characters are set.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.AutoCSetChooseSingle)
{If you use AutoCSetChooseSingle(True) and a list has only one item, it is automatically added and no list is displayed. The default is to display the list even if there is only a single item.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.AutoCGetChooseSingle)
{See <%LINK AutoCSetChooseSingle%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.AutoCSetIgnoreCase)
{By default, matching of characters to list members is case sensitive.
If True, ignores case when matching.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.AutoCGetIgnoreCase)
{See <%LINK AutoCSetIgnoreCase%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.AutoCSetAutoHide)
{By default, the list is cancelled if there are no viable matches (the user has typed characters that no longer match a list entry).

If you want to keep displaying the original list, set 'autoHide' to false.
This also effects <%LINK AutoCSelect%>.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.AutoCGetAutoHide)
{See <%LINK AutoCSetAutoHide%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.AutoCSetDropRestOfWord)
{When an item is selected, any word characters following the caret are first erased if 'dropRestOfWord' is set True.
The default is False.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.AutoCGetDropRestOfWord)
{See <%LINK AutoCSetDropRestOfWord%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.AutoCSetTypeSeparator)
{Autocompletion list items may display an image as well as text.
Each image is first registered with an integer type.
Then this integer is included in the text of the list separated by a '?' from the text.
For example, "fclose?2 fopen" displays image 2 before the string "fclose" and no image
before "fopen".

The images are in XPM format as is described for <%LINK MarkerDefinePixmap%>.
The set of registered images can be cleared with <%LINK ClearRegisteredImages%> and the '?' separator
changed with AutoCSetTypeSeparator.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.ClearRegisteredImages)
{Clears all registered images.<%SEEALSO AutoCSetTypeSeparator,AutoCGetTypeSeparator,RegisterImage%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.RegisterImage)
{Registers a image.<%SEEALSO AutoCSetTypeSeparator,AutoCGetTypeSeparator,ClearRegisteredImages%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.AutoCGetTypeSeparator)
{See <%LINK AutoCSetTypeSeparator%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.MarkerSetFore)
{Set foreground of the marker 'markerNumber'}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.MarkerSetBack)
{Set background of the marker 'markerNumber'}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.MarkerAdd)
{Adds marker number 'markerNumber' to a line.
The method returns -1 if this fails (illegal line number, out of memory) or it returns
a marker handle number that identifies the added marker.

You can use this returned handle with <LINK MarkerLineFromHandle%> to find where a marker
is after moving or combining lines and with <%LINK MarkerDeleteHandle%> to delete the marker
based on its handle.

The method does not check the value of 'markerNumber', nor does it check if the line already
contains the marker.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.MarkerDelete)
{This searches the given line number for the given marker number and deletes it if it is present. If you added the same marker more than once to the line, this will delete one copy each time it is used. If you pass in a marker number of -1, all markers are deleted from the line.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.MarkerDeleteAll)
{removes markers of the given 'markerNumber' from all lines.
If markerNumber is -1, it deletes all markers from all lines.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.MarkerGet)
{Returns a 32-bit integer that indicates which markers were present on the line. Bit 0 is set if marker 0 is present, bit 1 for marker 1 and so on.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.MarkerNext)
{Search efficiently for lines that include a given set of markers.

The search starts at line number 'lineStart' and continues forwards to the end of the file.
The 'markerMask' argument should have one bit set for each marker you wish to find.
Set bit 0 to find marker 0, bit 1 for marker 1 and so on.

The message returns the line number of the first line that contains one of the markers
in markerMask or -1 if no marker is found.<%SEEALSO MarkerPrevious%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.MarkerPrevious)
{Search efficiently for lines that include a given set of markers.

The search starts at line number 'lineStart' and continues backwards to the start of the file.
The 'markerMask' argument should have one bit set for each marker you wish to find.
Set bit 0 to find marker 0, bit 1 for marker 1 and so on.

The message returns the line number of the first line that contains one of the markers
in markerMask or -1 if no marker is found.<%SEEALSO MarkerNext%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.MarkerLineFromHandle)
{The 'markerHandle' argument is an identifier for a marker returned by <%LINK MarkerAdd%>.

This function searches the document for the marker with this handle and returns the linenumber
that contains it or -1 if it is not found.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.MarkerDeleteHandle)
{The 'markerHandle' argument is an identifier for a marker returned by <%LINK MarkerAdd%>.

This function searches the document for the marker with this handle and deletes the marker if it is found.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.MarkerDefine)
{This method associates a marker number in the range 0 to 31 with one of the marker symbols or an ASCII character.

The general-purpose marker symbols currently available are:
SC_MARK_CIRCLE, SC_MARK_ROUNDRECT, SC_MARK_ARROW, SC_MARK_SMALLRECT, SC_MARK_SHORTARROW, SC_MARK_EMPTY, SC_MARK_ARROWDOWN, SC_MARK_MINUS, SC_MARK_PLUS, SC_MARK_ARROWS, SC_MARK_DOTDOTDOT, SC_MARK_EMPTY and SC_MARK_BACKGROUND.


<%BOLD%>MARKERS<%TEXT%>
There are 32 markers, numbered 0 to 31, and you can assign any combination of them to each line in the document. Markers appear in the selection margin to the left of the text. If the selection margin is set to zero width, the background colour of the whole line is changed instead. Marker numbers 25 to 31 are used by Scintilla in folding margins, and have symbolic names of the form SC_MARKNUM_*, for example SC_MARKNUM_FOLDEROPEN.

Marker numbers 0 to 24 have no pre-defined function; you can use them to mark syntax errors or the current point of execution, break points, or whatever you need marking. If you do not need folding, you can use all 32 for any purpose you wish.

Each marker number has a symbol associated with it. You can also set the foreground and background colour for each marker number, so you can use the same symbol more than once with different colouring for different uses. Scintilla has a set of symbols you can assign (SC_MARK_*) or you can use characters. By default, all 32 markers are set to SC_MARK_CIRCLE with a black foreground and a white background.

The markers are drawn in the order of their numbers, so higher numbered markers appear on top of lower numbered ones. Markers try to move with their text by tracking where the start of their line moves.
When a line is deleted, its markers are combined, by an OR operation, with the markers of the previous line.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.MarkerDefinePixmap)
{Markers can be set to pixmaps with this message. The XPM format is used for the pixmap and it is limited to pixmaps that use one character per pixel. The data should be null terminated. Pixmaps use the SC_MARK_PIXMAP marker symbol. You can find the full description of the XPM format here.

The SC_MARK_BACKGROUND marker changes the background colour of the line only. The SC_MARK_EMPTY symbol is invisible, allowing client code to track the movement of lines. You would also use it if you changed the folding style and wanted one or more of the SC_FOLDERNUM_* markers to have no associated symbol.

There are also marker symbols designed for use in the folding margin in a flattened tree style.
SC_MARK_BOXMINUS, SC_MARK_BOXMINUSCONNECTED, SC_MARK_BOXPLUS, SC_MARK_BOXPLUSCONNECTED, SC_MARK_CIRCLEMINUS, SC_MARK_CIRCLEMINUSCONNECTED, SC_MARK_CIRCLEPLUS, SC_MARK_CIRCLEPLUSCONNECTED, SC_MARK_LCORNER, SC_MARK_LCORNERCURVE, SC_MARK_TCORNER, SC_MARK_TCORNERCURVE, and SC_MARK_VLINE.


Characters can be used as markers by adding the ASCII value of the character to SC_MARK_CHARACTER (10000). For example, to use 'A' (ASCII code 65) as marker number 1 use:
SCI_MARKETDEFINE(1, SC_MARK_CHARACTER+65).



The marker numbers SC_MARKNUM_FOLDER and SC_MARKNUM_FOLDEROPEN are used for showing that a fold is present and open or closed. Any symbols may be assigned for this purpose although the (SC_MARK_PLUS, SC_MARK_MINUS) pair or the (SC_MARK_ARROW, SC_MARK_ARROWDOWN) pair are good choices. As well as these two, more assignments are needed for the flattened tree style: SC_MARKNUM_FOLDEREND, SC_MARKNUM_FOLDERMIDTAIL, SC_MARKNUM_FOLDEROPENMID, SC_MARKNUM_FOLDERSUB, and SC_MARKNUM_FOLDERTAIL. The bits used for folding are specified by SC_MASK_FOLDERS, which is commonly used as an argument to <%LINK SetMarginMaskN%> when defining a margin to be used for folding.
}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.AssignCmdKey)
{This assigns the given key definition (km) to a Scintilla command identified by 'msg'. 'msg' can be any SCI_* command that has no arguments.

<%BOLD%>Keybindings<%TEXT%>

<%ITALIC%>keyDefinition<%TEXT%>
A key definition contains the key code in the low 16-bits and the key modifiers in the high 16-bits. To combine keyCode and keyMod set:

keyDefinition = keyCode + (keyMod << 16)

The key code is a visible or control character or a key from the SCK_* enumeration, which contains:
SCK_ADD,SCK_BACK,SCK_DELETE
SCK_DIVIDE,SCK_DOWN,SCK_END
SCK_ESCAPE,SCK_HOME,SCK_INSERT
SCK_LEFT,SCK_NEXT (Page Down),SCK_PRIOR (Page Up)
SCK_RETURN,SCK_RIGHT,SCK_SUBTRACT
SCK_TAB,SCK_UP,.

The modifiers are a combination of zero or more of SCMOD_ALT, SCMOD_CTRL, and SCMOD_SHIFT. If you are building a table, you might want to use SCMOD_NORM, which has the value 0, to mean no modifiers.

<%BOLD%>Keyboard Commands<%TEXT%>

To allow the container application to perform any of the actions available to the user with keyboard, all the keyboard actions are messages.
They do not take any parameters.
These commands are also used when redefining the key bindings with the AssignCmdKey method.

SCI_LINEDOWN,SCI_LINEDOWNEXTEND
SCI_LINEDOWNRECTEXTEND,SCI_LINESCROLLDOWN
SCI_LINEUP,SCI_LINEUPEXTEND
SCI_LINEUPRECTEXTEND,SCI_LINESCROLLUP
SCI_PARADOWN,SCI_PARADOWNEXTEND
SCI_PARAUP,SCI_PARAUPEXTEND
SCI_CHARLEFT,SCI_CHARLEFTEXTEND
SCI_CHARLEFTRECTEXTEND,SCI_CHARRIGHT
SCI_CHARRIGHTEXTEND,SCI_CHARRIGHTRECTEXTEND
SCI_WORDLEFT,SCI_WORDLEFTEXTEND
SCI_WORDRIGHT,SCI_WORDRIGHTEXTEND
SCI_WORDLEFTEND,SCI_WORDLEFTENDEXTEND
SCI_WORDRIGHTEND,SCI_WORDRIGHTENDEXTEND
SCI_WORDPARTLEFT,SCI_WORDPARTLEFTEXTEND
SCI_WORDPARTRIGHT,SCI_WORDPARTRIGHTEXTEND
SCI_HOME,SCI_HOMEEXTEND
[SCI_HOMERECTEXTEND],SCI_HOMEDISPLAY
SCI_HOMEDISPLAYEXTEND,SCI_HOMEWRAP
SCI_HOMEWRAPEXTEND,SCI_VCHOME
SCI_VCHOMEEXTEND,SCI_VCHOMERECTEXTEND
SCI_VCHOMEWRAP,SCI_VCHOMEWRAPEXTEND
SCI_LINEEND,SCI_LINEENDEXTEND
SCI_LINEENDRECTEXTEND,SCI_LINEENDDISPLAY
SCI_LINEENDDISPLAYEXTEND,SCI_LINEENDWRAP
SCI_LINEENDWRAPEXTEND,SCI_DOCUMENTSTART
SCI_DOCUMENTSTARTEXTEND,SCI_DOCUMENTEND
SCI_DOCUMENTENDEXTEND,SCI_PAGEUP
SCI_PAGEUPEXTEND,SCI_PAGEUPRECTEXTEND
SCI_PAGEDOWN,SCI_PAGEDOWNEXTEND
SCI_PAGEDOWNRECTEXTEND,SCI_STUTTEREDPAGEUP
SCI_STUTTEREDPAGEUPEXTEND,SCI_STUTTEREDPAGEDOWN
SCI_STUTTEREDPAGEDOWNEXTEND,SCI_DELETEBACK
SCI_DELETEBACKNOTLINE,SCI_DELWORDLEFT
SCI_DELWORDRIGHT,SCI_DELLINELEFT
SCI_DELLINERIGHT,SCI_LINEDELETE
SCI_LINECUT,SCI_LINECOPY
SCI_LINETRANSPOSE,SCI_LINEDUPLICATE
SCI_LOWERCASE,SCI_UPPERCASE
SCI_CANCEL,SCI_EDITTOGGLEOVERTYPE
SCI_NEWLINE,SCI_FORMFEED
SCI_TAB,SCI_BACKTAB


The SCI_*EXTEND messages extend the selection.

The SCI_*RECTEXTEND messages extend the rectangular selection (and convert regular selection to rectangular one, if any).

The SCI_WORDPART* commands are used to move between word segments marked by capitalisation (aCamelCaseIdentifier) or underscores (an_under_bar_ident).

The SCI_HOME* commands move the caret to the start of the line, while the SCI_VCHOME*commands move the caret to the first non-blank character of the line (ie. just after the indentation) unless it is already there; in this case, it acts as SCI_HOME*.

The SCI_[HOME|LINEEND]DISPLAY* commands are used when in line wrap mode to allow movement to the start or end of display lines as opposed to the normal SCI_[HOME|LINEEND] commands which move to the start or end of document lines.

The SCI_[[VC]HOME|LINEEND]WRAP* commands are like their namesakes SCI_[[VC]HOME|LINEEND]* except they behave differently when word-wrap is enabled: They go first to the start / end of the display line, like SCI_[HOME|LINEEND]DISPLAY*, but if the cursor is already at the point, it goes on to the start or end of the document line, as appropriate for SCI_[[VC]HOME|LINEEND]*.
}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.ClearCmdKey)
{This makes the given key definition do nothing by assigning the action SCI_NULL to it. See <%LINK AssignCmdKey%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.ClearAllCmdKeys)
{This command removes all keyboard command mapping by setting an empty mapping table. See <%LINK AssignCmdKey%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.Null)
{The SCI_NULL does nothing and is the value assigned to keys that perform no action.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetCodePage)
{Scintilla has some support for Japanese, Chinese and Korean DBCS. Use this message with codePage set to the code page number to set Scintilla to use code page information to ensure double byte characters are treated as one character rather than two. This also stops the caret from moving between the two bytes in a double byte character. Call with codePage set to zero to disable DBCS support. The default is SCI_SETCODEPAGE(0).

Code page SC_CP_UTF8 (65001) sets Scintilla into Unicode mode with the document treated as a sequence of characters expressed in UTF-8. The text is converted to the platform's normal Unicode encoding before being drawn by the OS and thus can display Hebrew, Arabic, Cyrillic, and Han characters. Languages which can use two characters stacked vertically in one horizontal space, such as Thai, will mostly work but there are some issues where the characters are drawn separately leading to visual glitches. Bi-directional text is not supported.

On Windows, code page can be set to 932 (Japanese Shift-JIS), 936 (Simplified Chinese GBK), 949 (Korean), and 950 (Traditional Chinese Big5) although these may require installation of language specific support.

Setting codePage to a non-zero value that is not SC_CP_UTF8 is operating system dependent.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetCodePage)
{Returns current codepage.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetTwoPhaseDraw)
{Two phase drawing is a better but slower way of drawing text. In single phase drawing each run of characters in one style is drawn along with its background. If a character overhangs the end of a run, such as in "V_" where the "V" is in a different style from the "_", then this can cause the right hand side of the "V" to be overdrawn by the background of the "_" which cuts it off. Two phase drawing fixes this by drawing all the backgrounds first and then drawing the text in transparent mode. Two phase drawing may flicker more than single phase unless buffered drawing is on. The default is for drawing to be two phase.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetTwoPhaseDraw)
{See <%LINK SetTwoPhaseDraw%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetUsePalette)
{On 8 bit displays, which can only display a maximum of 256 colours, the graphics environment mediates between the colour needs of applications through the use of palettes. On GTK+, Scintilla always uses a palette.

On Windows, there are some problems with visual flashing when switching between applications with palettes and it is also necessary for the application containing the Scintilla control to forward some messages to Scintilla for its palette code to work. Because of this, by default, the palette is not used and the application must tell Scintilla to use one. If Scintilla is not using a palette, it will only display in those colours already available, which are often the 20 Windows system colours.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetUsePalette)
{See <%LINK SetUsePalette%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetBufferedDraw)
{Turn buffered drawing on or off and report the buffered drawing state. Buffered drawing draws each line into a bitmap rather than directly to the screen and then copies the bitmap to the screen. This avoids flickering although it does take longer. The default is for drawing to be buffered.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetBufferedDraw)
{See <%LINK SetBufferedDraw%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetFoldMarginColour)
{Sets the color of the fold margin. On Windows the fold margin colour defaults to ::GetSysColor(COLOR_3DFACE).}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetFoldMarginHiColour)
{Sets the color of the fold margin highlight. On Windows the fold margin colour defaults to ::GetSysColor(COLOR_3DHIGHLIGHT).}
//CE_Desc_End

//CE_Desc_Begin(TScintillaBase.SetMarginLeft)
{Set left margin. Default: 1 pixel}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetMarginRight)
{Set right margin. Default: 1 pixel}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetMarginLeft)
{Get left margin. Default: 1 pixel}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetMarginRight)
{Get right margin. Default: 1 pixel}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetMarginMaskN)
{The mask is a 32-bit value. Each bit corresponds to one of 32 logical symbols that can be displayed in a margin that is enabled for symbols. There is a useful constant, SC_MASK_FOLDERS (0xFE000000 or -33554432), that is a mask for the 7 logical symbols used to denote folding. You can assign a wide range of symbols and colours to each of the 32 logical symbols, see Markers for more information. If (mask & SC_MASK_FOLDERS)==0, the margin background colour is controlled by style 33 (STYLE_LINENUMBER).

You add logical markers to a line with <%LINK MarkerAdd%>. If a line has an associated marker that does not appear in the mask of any margin with a non-zero width, the marker changes the background colour of the line. For example, suppose you decide to use logical marker 10 to mark lines with a syntax error and you want to show such lines by changing the background colour. The mask for this marker is 1 shifted left 10 times (1<<10) which is 0x400. If you make sure that no symbol margin includes 0x400 in its mask, any line with the marker gets the background colour changed.

To set a non-folding margin 1 use SetMarginMaskN(1, ~SC_MASK_FOLDERS); to set a folding margin 2 use SCI_SETMARGINMASKN(2, SC_MASK_FOLDERS). This is the default set by Scintilla. ~SC_MASK_FOLDERS is 0x1FFFFFF in hexadecimal or 33554431 decimal. Of course, you may need to display all 32 symbols in a margin, in which case use SetMarginMaskN(margin, -1).}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetMarginMaskN)
{See <%LINK SetMarginMaskN%>}
//CE_Desc_End

//CE_Desc_Begin(TScintillaBase.SetMarginWidthN)
{Set the width of a margin in pixels. A margin with zero width is invisible. By default, Scintilla sets margin 1 for symbols with a width of 16 pixels, so this is a reasonable guess if you are not sure what would be appropriate. Line number margins widths should take into account the number of lines in the document and the line number style. You could use something like <%LINK TextWidth%>(STYLE_LINENUMBER, "_99999") to get a suitable width.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetMarginWidthN)
{See <%LINK SetMarginWidthN%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetMarginTypeN)
{Set the type of a margin. The margin argument should be 0, 1 or 2. You can use the predefined constants SC_MARGIN_SYMBOL (0) and SC_MARGIN_NUMBER (1) to set a margin as either a line number or a symbol margin. By convention, margin 0 is used for line numbers and the other two are used for symbols.

<%BOLD%>Margins<%TEXT%>

There may be up to three margins to the left of the text display, plus a gap either side of the text. Each margin can be set to display either symbols or line numbers with SetMarginTypeN. The markers that can be displayed in each margin are set with <%LINK SetMarginMaskN%>. Any markers not associated with a visible margin will be displayed as changes in background colour in the text. A width in pixels can be set for each margin. Margins with a zero width are ignored completely. You can choose if a mouse click in a margin sends a <%LINK OnMarginClick%> event to the container or selects a line of text.

The margins are numbered 0 to 2. Using a margin number outside the valid range has no effect. By default, margin 0 is set to display line numbers, but is given a width of 0, so it is hidden. Margin 1 is set to display non-folding symbols and is given a width of 16 pixels, so it is visible. Margin 2 is set to display the folding symbols, but is given a width of 0, so it is hidden. Of course, you can set the margins to be whatever you wish.
}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetMarginTypeN)
{See <%LINK SetMarginTypeN%>}
//CE_Desc_End

//CE_Desc_Begin(TScintillaBase.SetMarginSensitiveN)
{Each of the three margins can be set sensitive or insensitive to mouse clicks. A click in a sensitive margin sends a <%LINK OnMarginClick%> event to the container. Margins that are not sensitive act as selection margins which make it easy to select ranges of lines. By default, all margins are insensitive.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetMarginSensitiveN)
{See <%LINK SetMarginSensitiveN%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetCaretWidth)
{The width of the caret can be set with SCI_SETCARETWIDTH to a value of 0, 1, 2 or 3 pixels. The default width is 1 pixel.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetCaretWidth)
{Returns the caret width.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetCaretPeriod)
{The rate at which the caret blinks can be set with SCI_SETCARETPERIOD which determines the time in milliseconds that the caret is visible or invisible before changing state. Setting the period to 0 stops the caret blinking. The default value is 500 milliseconds.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetCaretPeriod)
{Returns the current caret blink period.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetCaretLineBack)
{You can choose to make the background colour of the line containing the caret different.

To do this, set the desired background colour with SetCaretLineBack, then use <%LINK SetCaretLineVisible%>(True) to enable the effect.
You can cancel the effect with <%LINK SetCaretLineVisible%>(False).}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetCaretLineBack)
{See <%LINK SetCaretLineBack%>}
//CE_Desc_End

//CE_Desc_Begin(TScintillaBase.SetCaretLineVisible)
{See <%LINK SetCaretLineBack%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetCaretLineVisible)
{See <%LINK SetCaretLineBack%>}
//CE_Desc_End

//CE_Desc_Begin(TScintillaBase.SetHotspotActiveFore)
{While the cursor hovers over text in a style with the hotspot attribute set, the default colouring can be modified and an underline drawn with these settings. Single line mode stops a hotspot from wrapping onto next line.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetHotspotActiveBack)
{See <%LINK SetHotspotActiveFore%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetHotspotActiveUnderline)
{See <%LINK SetHotspotActiveFore%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetHotspotSingleLine)
{See <%LINK SetHotspotActiveFore%>}
//CE_Desc_End

//CE_Desc_Begin(TScintillaBase.StyleClearAll)
{This method sets all styles to have the same attributes as STYLE_DEFAULT (32). If you are setting up Scintilla for syntax colouring, it is likely that the lexical styles you set will be very similar. One way to set the styles is to:
1. Set STYLE_DEFAULT to the common features of all styles.
2. Use StyleClearAll to copy this to all styles.
3. Set the style attributes that make your lexical styles different.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.StyleSetFont)
{These methods (plus <%LINK StyleSetCharacterSet%>) set the font attributes that are used to match the fonts you request to those available. The fontName is a zero terminated string holding the name of a font. Under Windows, only the first 32 characters of the name are used and the name is not case sensitive. For internal caching, Scintilla tracks fonts by name and does care about the casing of font names, so please be consistent.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.StyleSetUnderline)
{You can set a style to be underlined. The underline is drawn in the foreground colour. All characters with a style that includes the underline attribute are underlined, even if they are white space.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.StyleSetSize)
{See <%LINK StyleSetFont%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.StyleSetBold)
{See <%LINK StyleSetFont%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.StyleSetItalic)
{See <%LINK StyleSetFont%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.StyleSetFore)
{Style Text color.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.StyleSetBack)
{Style Background color.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.StyleSetEOLFilled)
{If the last character in the line has a style with this attribute set, the remainder of the line up to the right edge of the window is filled with the background colour set for the last character. This is useful when a document contains embedded sections in another language such as HTML pages with embedded JavaScript. By setting eolFilled to true and a consistent background colour (different from the background colour set for the HTML styles) to all JavaScript styles then JavaScript sections will be easily distinguished from HTML.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.StyleSetCharacterSet)
{You can set a style to use a different character set than the default. The places where such characters sets are likely to be useful are comments and literal strings. For example, SCI_STYLESETCHARACTERSET(SCE_C_STRING, SC_CHARSET_RUSSIAN) would ensure that strings in Russian would display correctly in C and C++ (SCE_C_STRING is the style number used by the C and C++ lexer to display literal strings; it has the value 6). This feature currently only works fully on Windows.

The character sets supported on Windows are:
SC_CHARSET_ANSI, SC_CHARSET_ARABIC, SC_CHARSET_BALTIC, SC_CHARSET_CHINESEBIG5, SC_CHARSET_DEFAULT, SC_CHARSET_EASTEUROPE, SC_CHARSET_GB2312, SC_CHARSET_GREEK, SC_CHARSET_HANGUL, SC_CHARSET_HEBREW, SC_CHARSET_JOHAB, SC_CHARSET_MAC, SC_CHARSET_OEM, SC_CHARSET_SHIFTJIS, SC_CHARSET_SYMBOL, SC_CHARSET_THAI, SC_CHARSET_TURKISH, and SC_CHARSET_VIETNAMESE.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.StyleSetCase)
{The value of caseMode determines how text is displayed. You can set upper case (SC_CASE_UPPER, 1) or lower case (SC_CASE_LOWER, 2) or display normally (SC_CASE_MIXED, 0). This does not change the stored text, only how it is displayed.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.StyleSetVisible)
{Text is normally visible. However, you can completely hide it by giving it a style with the visible set to 0. This could be used to hide embedded formatting instructions or hypertext keywords in HTML or XML.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.StyleSetChangeable)
{This is an experimental and incompletely implemented style attribute. The default setting is changeable set true but when set false it makes text read-only. Currently it only stops the caret from being within not-changeable text and does not yet stop deleting a range that contains not-changeable text.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.StyleSetHotSpot)
{This style is used to mark ranges of text that can detect mouse clicks. The cursor changes to a hand over hotspots, and the foreground, and background colours may change and an underline appear to indicate that these areas are sensitive to clicking. This may be used to allow hyperlinks to other documents.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetWrapMode)
{Set wrapMode to SC_WRAP_WORD (1) to enable line wrapping and to SC_WRAP_NONE (0) to disable line wrapping.

<%BOLD%>Line wrapping<%TEXT%>

By default, Scintilla does not wrap lines of text. If you enable line wrapping, lines wider than the window width are continued on the following lines. Lines are broken after space or tab characters or between runs of different styles. If this is not possible because a word in one style is wider than the window then the break occurs after the last character that completely fits on the line. The horizontal scroll bar does not appear when wrap mode is on.

For wrapped lines Scintilla can draw visual flags (little arrows) at end of a a subline of a wrapped line and at begin of the next subline. These can be enabled individually, but if Scintilla draws the visual flag at begin of the next subline this subline will be indented by one char. Independent from drawing a visual flag at the begin the subline can have an indention.

Much of the time used by Scintilla is spent on laying out and drawing text. The same text layout calculations may be performed many times even when the data used in these calculations does not change. To avoid these unnecessary calculations in some circumstances, the line layout cache can store the results of the calculations. The cache is invalidated whenever the underlying data, such as the contents or styling of the document changes. Caching the layout of the whole document has the most effect, making dynamic line wrap as much as 20 times faster but this requires 7 times the memory required by the document contents plus around 80 bytes per line.

Wrapping is not performed immediately there is a change but is delayed until the display is redrawn. This delay improves peformance by allowing a set of changes to be performed and then wrapped and displayed once. Because of this, some operations may not occur as expected. If a file is read and the scroll position moved to a particular line in the text, such as occurs when a container tries to restore a previous editing session, then the scroll position will have been determined before wrapping so an unexpected range of text will be displayed. To scroll to the position correctly, delay the scroll until the wrapping has been performed by waiting for an initial <%LINK OnPainted%> event.
}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetWrapMode)
{See <%LINK SetWrapMode%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetWrapVisualFlagsLocation)
{You can set wether the visual flags to indicate a line is wrapped are drawn near the border or near the text. Bits set with SetWrapVisualFlagsLocation set the location to near the text for the corresponding visual flag.

See Scintilla Documentation for more info.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetWrapVisualFlags)
{See <%LINK SetWrapVisualFlags%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetWrapVisualFlags)
{You can enable the drawing of visual flags to indicate a line is wrapped. Bits set in wrapVisualFlags determine which visual flags are drawn.

See Scintilla Documentation for more info.

Subline is indented by at least 1 to make room for the flag.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetWrapVisualFlagsLocation)
{See <%LINK SetWrapVisualFlagsLocation%>}
//CE_Desc_End

//CE_Desc_Begin(TScintillaBase.SetBackSpaceUnIndents)
{Inside indentation white space, the tab and backspace keys can be made to indent and unindent rather than insert a tab character or delete a character with the <%LINK SetTabIndents%> and SetBackSpaceUnIndents functions.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetBackSpaceUnIndents)
{See <%LINK SetBackSpaceUnIndents%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetTabIndents)
{Inside indentation white space, the tab and backspace keys can be made to indent and unindent rather than insert a tab character or delete a character with the SetTabIndents and <%LINK SetBackSpaceUnIndents%> functions.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetTabIndents)
{See <%LINK SetTabIndents%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetPrintMagnification)
{Lets you to print at a different size than the screen font.
'magnification' is the number of points to add to the size of each screen font.
A value of -3 or -4 gives reasonably small print.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetPrintMagnification)
{Returns the current magnification.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetPrintColourMode)
{Sets the method used to render coloured text on a printer that is probably using white paper. It is especially important to consider the treatment of colour if you use a dark or black screen background. Printing white on black uses up toner and ink very many times faster than the other way around. You can set the mode to one of:

See Scintilla Documentation for more info.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetPrintColourMode)
{See <%LINK SetPrintColourMode%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetPrintWrapMode)
{Set the printer wrap mode.
'wrapMode' can be set to SC_WRAP_NONE (0) or SC_WRAP_WORD (1).
The default is SC_WRAP_WORD, which wraps printed output so that all characters fit into the print rectangle. If you set SC_WRAP_NONE, each line of text generates one line of output and the line is truncated if it is too long to fit into the print area.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetPrintWrapMode)
{See <%LINK SetPrintWrapMode%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetEdgeColumn)
{Set the column number at which to display the long line marker.
When drawing lines, the column sets a position in units of the width of a space character in STYLE_DEFAULT (32).
When setting the background colour, the column is a character count (allowing for tabs) into the line.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetEdgeColumn)
{See <%LINK SetEdgeColumn%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetEdgeColour)
{Sets the colour of the marker used to show that a line has exceeded the length set by <%LINK SetEdgeColumn%>.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetEdgeColour)
{Gets the colour of the marker used to show that a line has exceeded the length set by <%LINK SetEdgeColumn%>.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetEdgeMode)
{Set the mode used to display long lines. 

See Scintilla Documentation for more info.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetEdgeMode)
{See <%LINK SetEdgeMode%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetHighlightGuide)
{When brace highlighting occurs, the indentation guide corresponding to the braces may be highlighted with the brace highlighting style, STYLE_BRACELIGHT (34). Set column to 0 to cancel this highlight.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetHighlightGuide)
{See <%LINK SetHighlightGuide%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetEndAtLastLine)
{sets the scroll range so that maximum scroll position has the last line at the bottom of the view (default). Setting this to False allows scrolling one page below the last line.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetEndAtLastLine)
{See <%LINK SetEndAtLastLine%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetEOLMode)
{Sets the characters that are added into the document when the user presses the Enter key.
You can set 'eolMode' to one of SC_EOL_CRLF (0), SC_EOL_CR (1), or SC_EOL_LF (2).<%SEEALSO GetEOLMode%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetEOLMode)
{Returns the characters that are added into the document when the user presses the Enter key.
It can be one of SC_EOL_CRLF (0), SC_EOL_CR (1), or SC_EOL_LF (2).<%SEEALSO SetEOLMode%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetIndent)
{Sets the size of indentation in terms of the width of a space in STYLE_DEFAULT. If you set a width of 0, the indent size is the same as the tab size. There are no limits on indent sizes, but values less than 0 or large values may have undesirable effects.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetIndent)
{See <%LINK SetIndent%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetIndentationGuides)
{Indentation guides are dotted vertical lines that appear within indentation white space every indent size columns. They make it easy to see which constructs line up especially when they extend over multiple pages. Style STYLE_INDENTGUIDE (37) is used to specify the foreground and background colour of the indentation guides.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetIndentationGuides)
{See <%LINK SetIndentationGuides%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetHScrollBar)
{The horizontal scroll bar is only displayed if it is needed for the assumed width.
If you never wish to see it, call SetHScrollBar(False). Use SetHScrollBar(True) to enable it again.
SCI_GETHSCROLLBAR. The default state is to display it when needed.<%SEEALSO SetScrollWidth%>.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetHScrollBar)
{Returns true if the Horizontal scrollbar is visible.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetModEventMask)
{Set an event mask that determines which document change events are notified to the container with <%LINK OnModified%> and SCEN_CHANGE.

For example, a container may decide to see only notifications about changes to text and not styling changes by calling SCI_SETMODEVENTMASK(SC_MOD_INSERTTEXT|SC_MOD_DELETETEXT).

The possible notification types are the same as the modificationType bit flags used by SCN_MODIFIED: SC_MOD_INSERTTEXT, SC_MOD_DELETETEXT, SC_MOD_CHANGESTYLE, SC_MOD_CHANGEFOLD, SC_PERFORMED_USER, SC_PERFORMED_UNDO, SC_PERFORMED_REDO, SC_LASTSTEPINUNDOREDO, SC_MOD_CHANGEMARKER, SC_MOD_BEFOREINSERT, SC_MOD_BEFOREDELETE, and SC_MODEVENTMASKALL.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetModEventMask)
{See <%LINK SetModEventMask%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetMouseDwellTime)
{Sets the time the mouse must sit still, in milliseconds, to generate a <%LINK OnDwellStart%> event. If set to SC_TIME_FOREVER, the default, no dwell events are generated.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetMouseDwellTime)
{Returns the time the mouse must sit still, in milliseconds, to generate a <%LINK OnDwellStart%> event. If set to SC_TIME_FOREVER, the default, no dwell events are generated.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetTabWidth)
{Sets the size of a tab as a multiple of the size of a space character in STYLE_DEFAULT. The default tab width is 8 characters. There are no limits on tab sizes, but values less than 1 or large values may have undesirable effects.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetTabWidth)
{See <%LINK SetTabWidth%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetUseTabs)
{Determines whether indentation should be created out of a mixture of tabs and spaces or be based purely on spaces.
Set 'useTabs' to False (0) to create all tabs and indents out of spaces.
The default is True.

You can use <%LINK GetColumn%> to get the column of a position taking the width of a tab into account.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetUseTabs)
{See <%LINK SetUseTabs%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetWrapStartIndent)
{Sets the size of indentation of sublines for wrapped lines in terms of the width of a space in STYLE_DEFAULT.
There are no limits on indent sizes, but values less than 0 or large values may have undesirable effects.

The indention of sublines is independent of visual flags, but if SC_WRAPVISUALFLAG_START is set an indent of at least 1 is used.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetWrapStartIndent)
{See <%LINK SetWrapStartIndent%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetReadOnly)
{Set the read-only flag for the document.
If you mark a document as read only, attempts to modify the text cause the <%LINK OnModifyAttemptRO%> event.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetReadOnly)
{<%LINK SetReadOnly%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SelectAll)
{Selects all text.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetViewWS)
{White space can be made visible which may useful for languages in which white space is significant, such as Python. Space characters appear as small centred dots and tab characters as light arrows pointing to the right. There are also ways to control the display of end of line characters. The two messages set and get the white space display mode. 

See Scintilla Documentation for more info.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetViewWS)
{See <%LINK SetViewWS%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.CharLeft)
{Move the caret a character left.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.CharRight)
{Move the caret a character right.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.CharLeftExtend)
{Extends the selection a character left.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.CharRightExtend)
{Extends the selection a character right.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.CharLeftRectExtend)
{Extends the rectangular selection left (and convert regular selection to rectangular one, if any).}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.CharRightRectExtend)
{Extends the rectangular selection left (and convert regular selection to rectangular one, if any).}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.DeleteBack)
{Deletes the character to the left of caret. Moves the caret.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.DelWordLeft)
{Deletes the word to the left. Moves the caret.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.DelWordRight)
{Deletes the word to the left. Moves the caret.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.DocumentEnd)
{Moves the caret to the end of document.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.DocumentEndExtend)
{Extends the rectangular selection to the end of document.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.DocumentStart)
{Moves the caret to the start of document.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.DocumentStartExtend)
{Extends the rectangular selection to the end of document.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.EditToggleOvertype)
{Toggles OverType. See <%LINK SetOvertype%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.FormFeed)
{Insert a formfeed.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetLineSelStartPosition)
{Retrieve the position of the start the selection at the given line with INVALID_POSITION returned if no selection on this line.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetLineSelEndPosition)
{Retrieve the position of the start the selection at the given line with INVALID_POSITION returned if no selection on this line.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetStatus)
{If an error occurs, Scintilla may set an internal error number that can be retrieved with SCI_GETSTATUS. Not currently used but will be in the future. To clear the error status call SetStatus(0).}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetStatus)
{See <%LINK SetStatus%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetLayoutCache)
{See Scintilla Documentation for more info.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetLayoutCache)
{See <%LINK SetLayoutCache%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetFocusEx)
{On GTK+, focus handling is more complicated than on Windows, so Scintilla can be told with this message to grab the focus.

The internal focus flag can be set with SetFocusEx. This is used by clients that have complex focus requirements such as having their own window that gets the real focus but with the need to indicate that Scintilla has the logical focus.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetFocus)
{See <%LINK SetFocusEx%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GrabFocus)
{See <%LINK SetFocusEx%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.FindColumn)
{Returns the position of a 'column' on a 'line' taking the width of tabs into account.
It treats a multi-byte character as a single column.
Column numbers, like lines start at 0.
}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.TargetAsUTF8)
{Not handled under windows (yet).}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetLengthForEncode)
{Not handled under windows (yet).}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.EncodedFromUTF8)
{Not handled under windows (yet).}
//CE_Desc_End

{END Imported and customised help (mostly from the Scintilla Project). Added help for functions where it was none also.}

//CE_Desc_Begin(TScintillaBase.CopyFrom)
{Copies settings from 'Source' to this.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.WordLeftEnd)
{NOT DESCRIBED.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.WordLeftEndExtend)
{NOT DESCRIBED.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.WordRightEnd)
{NOT DESCRIBED.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.WordRightEndExtend)
{NOT DESCRIBED.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.UpperCase)
{Uppercases the selection. i.e abcde.... is transformed to ABCDE....}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.LowerCase)
{Uppercases the selection. i.e ABCDE.... is transformed to abcde....}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.LineTranspose)
{Swaps the current line with the line above.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.DelLineLeft)
{Delete the line from the caret position to the start of line.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.DelLineRight)
{Delete the line from the caret position to the end of line.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.NewLine)
{Inserts a new line at the current position. (same as when you press Enter)}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SPerform)
{Used internally for dispatching messages to the Scintilla control.
Can be used direct, but not recommended.
}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.LoadFromStream)
{Load text from a stream.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.LoadFromFile)
{Load text from the file with name FileName.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SaveToStream)
{Save text to a stream.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SaveToFile)
{Save buffer text to the text file with name FileName.
Saves ANSI text.
Alternatively the Lines.Text property in TScintilla derived classes give us raw UTF8 if needed (when  UseUnicode is true).}
//CE_Desc_End

//CE_Desc_Begin(TScintillaBase.SetVScrollBar)
{By default, the vertical scroll bar is always displayed when required.

You can choose to hide or show it with SetVScrollBar and get the current state with <%LINK GetVScrollBar%>.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetVScrollBar)
{See <%LINK SetVScrollBar%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetScrollWidth)
{For performance, Scintilla does not measure the display width of the document to determine the properties of the horizontal scroll bar. Instead, an assumed width is used. These messages set and get the document width in pixels assumed by Scintilla. The default value is 2000.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetScrollWidth)
{See <%LINK SetScrollWidth%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.ClearDocument)
{Clears the current document.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetCurrentScrollPosition)
{Returns the current scroll position. Position - First Visible Line}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetLineInBuf)
{Get the line 'linenum' into the buffer 'textbuf' of size 'sizeText'}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetLineS)
{Get the line as a AnsiString}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetRange)
{Get the range from 'start' to 'end_' into the buffer 'text'}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetSelectionRng)
{Returns start and end position for the current selection}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.FindWordAtCaret)
{Returns start and end_ positions for the word under the caret.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.RangeExtendAndGrab)
{Extend selection both ways while ischarforsel function returns true}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SelectionExtend)
{Extend selection both ways while ischarforsel function returns true}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SetSelectionS)
{Set selection start and end}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SelectWordAtCaret)
{Selects the word under the cursor.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SelectionWord)
{Selects the word under the cursor determined by iswordcharforsel.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SelectionFileName)
{Selects the filename under the cursor determined by isfilenamecharforsel.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetLineLength)
{Returns the length of 'lineno'. if 'lineno'=-1 then returns the length of the current line}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetCaretInLine)
{Returns the caret position in current line}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GetCurrentLineNumber)
{Returns the current linenumber}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.GotoLineEnsureVisible)
{Goto line and ensure it's visible}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.RangeIsAllWhiteSpace)
{Test if the range are only whitespace. Returns True if so.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.EnsureRangeVisible)
{Ensure a text range is visible - make visible if necessary}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.ExecuteAction)
{Standard Delphi edit action support}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.UpdateAction)
{Standard Delphi edit action support}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.ReadOnly)
{Set to true to make the text buffer read-only.
Remember, can't set the text by code either when it's true.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.UseUnicode)
{Setting to true allows the use of multiple language in the same document.  If true all text in and out of the control is interpreted as UTF8.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SelLength)
{Length of current selection.<%SEEALSO TScintillaBase.SelStart%> <%SEEALSO SelText%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SelStart)
{Start of current selection.<%SEEALSO TScintillaBase.SelLength%> <%SEEALSO SelText%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.SelText)
{The currently selected text.<%SEEALSO TScintillaBase.SelLength%><%SEEALSO SelStart%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.WordWrap)
{Enable/Disable WordWrapping}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.ClearUndoAfterSave)
{If True, clears the undobuffer when the document is saved.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.Dummy)
{If set to true an external object can receive all the calls to the scintilla control - nstead of calling scintilla we just pass on the messages. To enable this, set up a OnMsgSent handler _FIRST_, and then
set Dummy to true. This cannot be un-toggled!}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.Modified)
{Flag to indicate whether the text buffer has been modified.  Reset to false when the text is saved.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.WordChars)
{List of chars that's part of a word. Used by autocomplete etc.
Default: abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.Color)
{The default background color. Same as defining a style with the stylenumber 32.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.Font)
{The default font. Same as defining a style with the stylenumber 32.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.PopupMenu)
{See the Delphi Help for information on this property}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.Align)
{See the Delphi Help for information on this property}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.Hint)
{See the Delphi Help for information on this property}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.ShowHint)
{See the Delphi Help for information on this property}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.ParentShowHint)
{See the Delphi Help for information on this property}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.ParentFont)
{See the Delphi Help for information on this property}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.BorderStyle)
{See the Delphi Help for information on this property}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.Visible)
{See the Delphi Help for information on this property}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.doSciCharAdded)
{Called when the notification SCN_CHARADDED are received from the scintilla control.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.doSciMarginClick)
{Called when the notification SCN_MARGINCLICK are received from the scintilla control.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.doSciModified)
{Called when the notification SCN_MODIFIED are received from the scintilla control.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.doSciUpdateUI)
{Called when the notification SCN_UPDATEUI are received from the scintilla control.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.doSciUserListSelection)
{Called when the notification SCN_USERLISTSELECTION are received from the scintilla control.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.doSciCalltipClick)
{Called when the notification SCN_CALLTIPCLICK are received from the scintilla control.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.doSciDoubleClick)
{Called when the notification SCN_DOUBLECLICK are received from the scintilla control.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.doSciDwellEnd)
{Called when the notification SCN_DWELLEND are received from the scintilla control.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.doSciDwellStart)
{Called when the notification SCN_DWELLSTART are received from the scintilla control.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.doSciHotspotClick)
{Called when the notification SCN_HOTSPOTCLICK are received from the scintilla control.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.doSciHotspotDoubleClick)
{Called when the notification SCN_HOTSPOTDOUBLECLICK are received from the scintilla control.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.doSciKey)
{Called when the notification SCN_KEY are received from the scintilla control.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.doSciMacroRecord)
{Called when the notification SCN_MACRORECORD are received from the scintilla control.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.doSciHotspotClick)
{Called when the notification SCN_HOTSPOTCLICK are received from the scintilla control.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.doSciModifyAttemptRO)
{Called when the notification SCN_MODIFYATTEMPTRO are received from the scintilla control.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.doSciNeedShown)
{Called when the notification SCN_NEEDSHOWN are received from the scintilla control.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.doSciPainted)
{Called when the notification SCN_PAINTED are received from the scintilla control.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.doSciSavePointLeft)
{Called when the notification SCN_SAVEPOINTLEFT are received from the scintilla control.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.doSciSavePointReached)
{Called when the notification SCN_SAVEPOINTREACHED are received from the scintilla control.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.doSciStyleNeeded)
{Called when the notification SCN_STYLENEEDED are received from the scintilla control.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.doSciZoom)
{Called when the notification SCN_ZOOM are received from the scintilla control.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.OnKey)
{Not sent by windows.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.OnHotSpotClick)
{Fired when the user clicks on text that is in a style with the hotspot attribute set. This notification can be used to link to variable definitions or web pages. The position field is set the text position of the click or double click and the modifiers field set to the key modifiers held down.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.OnHotSpotDoubleClick)
{Fired when the user doubleclicks on text that is in a style with the hotspot attribute set. This notification can be used to link to variable definitions or web pages. The position field is set the text position of the click or double click and the modifiers field set to the key modifiers held down.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.OnStyleNeeded)
{Event handler triggered each time text needs styling for display if the Lexer language is set to 'container'}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.OnCharAdded)
{Event handler triggered when chars are added to the text buffer.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.OnSavePointReached)
{Event handler triggered when the save point is reached, allowing the container to hide a "document dirty" indicator and change its menus.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.OnSavePointLeft)
{Event handler triggered when the save point is left, allowing the container to display a "document dirty" indicator and change its menus.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.OnModifyAttemptRO)
{Event handler triggered when the user tries to modify a read-only buffer.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.OnDoubleClick)
{Fired when doubleclicked}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.OnUpdateUI)
{Event handler triggered  when either the text or styling of the document has changed or the selection range has changed. It is a good place to update any container UI elements that depend on document or view state.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.OnModified)
{Event handler triggered when the text or the styling of the text buffer changes.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.OnMacroRecord)
{Event handler triggered whenever a recordable change occurs while marco recording is on.  It is up to the programmer to save the recorded action.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.OnMarginClick)
{Event handler triggered when the user clicks on the margins (gutters)}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.OnURIDropped)
{Not used in windows.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.OnNeedShown)
{Event handler triggered when a range of lines that is currently invisible should be made visible. An example of where this may be needed is if the end of line of a contracted fold point is deleted.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.OnPainted)
{Event handler triggered when painting has just been done.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.OnUserListSelection)
{Event handler triggered when the user has selected an item in a user list.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.OnDwellStart)
{Fired when the user keeps the mouse in one position for the dwell period.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.OnDwellEnd)
{Fired after a <%LINK TScintillaBase.OnDwellStart,OnDwellStart%> and the mouse is moved or other activity such as key press indicates the dwell is over.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.OnZoom)
{Event handler triggered  when the user zooms the display using the keyboard or <%LINK TScintillaBase.SetZoom,SetZoom%> method is called.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.OnCallTipClick)
{Event handler triggered when the user clicks on calltip.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.OnMsgSent)
{When the property Dummy is set this event handler is called for every message that would be sent to the Scintilla contro otherwise.  Can be used for debugging purposes.}
//CE_Desc_End

//CE_Desc_Begin(TScintillaBase.LineCopy)
{Copies the line at caret position to clipboard.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.LineCut)
{Cuts the line at caret position to clipboard.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.LineDelete)
{Deletes the line at caret position.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.LineDown)
{Moves the line caret position down.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.LineDownExtend)
{Extends the selection a line down.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.LineDownRectExtend)
{Extends the rectangular selection a line down (and convert regular selection to rectangular one, if any).}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.LineUp)
{Moves the line caret position up.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.LineUpExtend)
{Extends the selection a line up.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.LineUpRectExtend)
{Extends the rectangular selection a line up (and convert regular selection to rectangular one, if any).}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.LineDuplicate)
{Duplicates the line at caret position.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.LineEnd)
{Moves the caret to the end of line.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.LineEndExtend)
{Extends the selection to the end of line.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.LineEndRectExtend)
{Extends the rectangular selection to the end of line (and convert regular selection to rectangular one, if any).}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.LineEndWrap)
{Same as <%LINK LineEnd%>, except when in wordwrap goes first to the end of display line, but if the cursor is already at the point, it goes on to the end of the document line.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.LineEndWrapExtend)
{Extends the selection to the end of line. See <%LINK LineEndWrap%> for more.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.LineEndWrapRectExtend)
{Extends the rectangular selection to the end of line (and convert regular selection to rectangular one, if any).
See <%LINK LineEndWrap%> for more.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.LineEndDisplay)
{Moves the caret to the end of the displayline.

Used when in line wrap mode to allow movement to the start or end of display lines as opposed to the normal Home|LineEnd commands which move to the start or end of document lines.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.LineEndDisplayExtend)
{Extends the selection to the end of the displayline.

Used when in line wrap mode to allow movement to the start or end of display lines as opposed to the normal Home|LineEnd commands which move to the start or end of document lines.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.Home)
{Moves the caret to the start of line.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.HomeExtend)
{Extends the selection to the start of line.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.HomeRectExtend)
{Extends the rectangular selection to the start of line (and convert regular selection to rectangular one, if any).}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.HomeWrap)
{Same as <%LINK Home%>, except when in wordwrap goes first to the start of display line, but if the cursor is already at the point, it goes on to the start of the document line.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.HomeWrapExtend)
{Extends the selection to the start of line. See <%LINK HomeWrap%> for more.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.HomeWrapRectExtend)
{Extends the rectangular selection to the start of line (and convert regular selection to rectangular one, if any).
See <%LINK HomeWrap%> for more.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.HomeDisplay)
{Moves the caret to the start of the displayline.

Used when in line wrap mode to allow movement to the start of display lines as opposed to the normal Home|LineEnd commands which move to the start or end of document lines.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.HomeDisplayExtend)
{Extends the selection to the start of the displayline.

Used when in line wrap mode to allow movement to the start of display lines as opposed to the normal Home|LineEnd commands which move to the start or end of document lines.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.PageUp)
{Moves the line caret position a page up.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.PageUpExtend)
{Extends the selection a page up.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.PageUpRectExtend)
{Extends the rectangular selection a line up (and convert regular selection to rectangular one, if any).}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.PageDown)
{Moves the line caret position a page down.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.PageDownExtend)
{Extends the selection a page down.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.PageDownRectExtend)
{Extends the rectangular selection a page down (and convert regular selection to rectangular one, if any).}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.ParaDown)
{Moves the line caret position a paragraph down.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.ParaDownExtend)
{Extends the selection a paragraph down.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.ParaUp)
{Moves the line caret position a paragraph up.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.ParaUpExtend)
{Extends the selection a paragraph up.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.StutteredPageUp)
{Moves the line caret position a page up.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.StutteredPageUpExtend)
{Extends the selection a page up.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.StutteredPageDown)
{Moves the line caret position a page down.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.StutteredPageDownExtend)
{Extends the selection a page down.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.VCHome)
{Move the caret to the first non-blank character of the line (ie. just after the indentation) unless it is already there; in this case, it acts as <%LINK Home%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.VCHomeExtend)
{Extends the selection to the first non-blank character of the line (ie. just after the indentation) unless it is already there; in this case, it acts as <%LINK HomeExtend%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.VCHomeRectExtend)
{Extends the rectangular selection to the first non-blank character of the line (ie. just after the indentation) (and convert regular selection to rectangular one, if any), unless it is already there; in this case, it acts as <%LINK HomeRectExtend%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.VCHomeWrap)
{Move the caret to the first non-blank character of the line (ie. just after the indentation) unless it is already there; in this case, it acts as <%LINK HomeWrap%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.VCHomeWrapExtend)
{Extends the selection first non-blank character of the displayline (ie. just after the indentation) unless it is already there; in this case, it acts as <%LINK HomeWrapExtend%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.WordLeft)
{Moves the caret a word left.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.WordRight)
{Moves the caret a word left.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.WordLeftExtend)
{Extends the selection a word left.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.WordRightExtend)
{Extends the selection a word right.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.WordPartLeftExtend)
{Extends the selection a wordpart left.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.WordPartRightExtend)
{Extends the selection a wordpart right.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.WordPartLeft)
{Moves the caret to the left wordpart.

Move between word segments marked by capitalisation (aCamelCaseIdentifier) or underscores (an_under_bar_ident).}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.WordPartRight)
{Moves the caret to the right wordpart.

Move between word segments marked by capitalisation (aCamelCaseIdentifier) or underscores (an_under_bar_ident).}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.Tab)
{Same as Tab on the keyboard.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaBase.BackTab)
{Same as Shift-Tab on the keyboard.}
//CE_Desc_End

//+++++++++++ Routines

//CE_Desc_Begin(iswordcharforsel)
{Returns True when the tested char is none of: #9#10#13#32!"#$%&(')*+-./:;<=>?@[\]^`{|}~,}
else False}
//CE_Desc_End
//CE_Desc_Begin(isfilenamecharforsel)
{Returns True when the tested char is none of: #9#10#13#32"$%*;<>?[]^`{|}',}
else False
//CE_Desc_End

//----------- SciCallTips.pas
//CE_Desc_Begin(SciCallTips.pas)
{Calltips component.}
//CE_Desc_End
//CE_Desc_Begin(TSciCallTips.Disabled)
{When True, disables all AutoCompletion}
//CE_Desc_End
//CE_Desc_Begin(TSciCallTips.ApiStrings)
{These are the functions/etc that calltips operates on.
These lines are defined in the same manner that they normally are declared.
i.e:

Format(const Format: string; const Args: array of const): string;}
//CE_Desc_End

//CE_Desc_Begin(TSciCallTips.ParametersSeparators)
{The character(s) that can separate parameters.
The default is ','}
//CE_Desc_End

//CE_Desc_Begin(TSciCallTips.ParametersStart)
{The character(s) that can start a parameter block.
The first character is the outer block start.
The default is '('}
//CE_Desc_End

//CE_Desc_Begin(TSciCallTips.ParametersEnd)
{The character(s) that can end a parameter block.
The first character is the outer block end.
The default is ')'}
//CE_Desc_End
//CE_Desc_Begin(TSciCallTips.WordCharacters)
{The characters that can make up a parameter name etc..}
//CE_Desc_End

//CE_Desc_Begin(TSciCallTips.Editor)
{The linked editor.}
//CE_Desc_End

//CE_Desc_Begin(TSciCallTips.EndDefinition)
{The character(s) that terminate the definition.
All text after that is description.
This is needed if you want the description on a separate line.

<%BOLD%>Example:<%TEXT%>

Notification(AComponent: TComponent; Operation: TOperation) This is the description.

To set this correct for the above line, set EndDefinition to ')'.
}
//CE_Desc_End
//CE_Desc_Begin(TSciCallTips.IgnoreCase)
{If True, then the functiondefinitions isn't casesensitive.}
//CE_Desc_End
//CE_Desc_Begin(TSciCallTips.HighlightColor)
{Sets the color of the highlighted portion of the calltip.. i.e the current parameter.}
//CE_Desc_End
//CE_Desc_Begin(TSciCallTips.ForeColor)
{Sets the color of the foreground of the calltip..}
//CE_Desc_End
//CE_Desc_Begin(TSciCallTips.BackColor)
{Sets the color of the background of the calltip..}
//CE_Desc_End


//----------- SciAutoComplete.pas
//CE_Desc_Begin(SciAutoComplete.pas)
{AutoCompletion component.}
//CE_Desc_End

//+++++++++++ TSciAutoComplete

//CE_Desc_Begin(TSciAutoComplete.Disabled)
{When True, disables all AutoCompletion}
//CE_Desc_End
//CE_Desc_Begin(TSciAutoComplete.NumStartChars)
{Number of characters required to start matching. Default: 1}
//CE_Desc_End
//CE_Desc_Begin(TSciAutoComplete.StopChars)
{List of characters that will automatically cancel the autocompletion list.}
//CE_Desc_End
//CE_Desc_Begin(TSciAutoComplete.StartChars)
{List of characters that's not normally a part of word, and will be
treated as a space when determining what can be autocompleted.

i.e if StartChars='$' and you have previously typed the word
'funny', and you type it again even with a preceding '$' like
this: $funny it will still match in the autocomplete list.

<%NOTE%>Is not related to the <%LINK TSciAutoComplete.NumStartChars,NumStartChars%> property.
}
//CE_Desc_End

//CE_Desc_Begin(TSciAutoComplete.AStrings)
{Strings inserted here are searched for autocompletion when a designated start character is pushed,
or when <%LINK CompleteWord%> is False.

<%NOTE%>Partially working.
}
//CE_Desc_End
//CE_Desc_Begin(TSciAutoComplete.IgnoreCase)
{If True : Ignores case when autocompleting}
//CE_Desc_End
//CE_Desc_Begin(TSciAutoComplete.Editor)
{The linked editor.}
//CE_Desc_End

//CE_Desc_Begin(TSciAutoComplete.ChooseSingle)
{If True and a list has only one item, it is automatically added and no list is displayed. The default is to display the list even if there is only a single item.}
//CE_Desc_End
//CE_Desc_Begin(TSciAutoComplete.AutoHide)
{By default, the list is cancelled if there are no viable matches (the user has typed characters that no longer match a list entry). If you want to keep displaying the original list, set AutoHide to false. This also affects <%LINK TSciAutoComplete.ChooseSingle%>}
//CE_Desc_End
//CE_Desc_Begin(TSciAutoComplete.DropRestOfWord)
{When an item is selected, any word characters following the caret are first erased if set to True. The default is false.}
//CE_Desc_End
//CE_Desc_Begin(TSciAutoComplete.CancelAtStart)
{The default behavior is for the list to be cancelled if the caret moves before the location it was at
when the list was displayed.

If false, the list is not cancelled until the caret moves before the first character of the word being completed.}
//CE_Desc_End
//CE_Desc_Begin(TSciAutoComplete.CompleteWord)
{If True, searches the document, and if one or more matches are found, displays choices
based on the findings. If CompleteWordOnlyOne is True, only displays when only a single
match is found.

If this if False, matches with the words in the <%LINK AStrings%> property.
}
//CE_Desc_End
//CE_Desc_Begin(TSciAutoComplete.CompleteWordOnlyOne)
{If True, searches the document, and if a autocompletematch is found, displays choices
based on the findings. If CompleteWordOnlyOne is True, only displays when only a single
match is found.}
//CE_Desc_End
//CE_Desc_Begin(TSciAutoComplete.Assign)
{Assigns the settings from 'Source' to this object.}
//CE_Desc_End

//----------- SciLexerMemo.pas
//CE_Desc_Begin(SciLexerMemo.pas)
{The TScintillaMemo component, more exposure of properties etc.}
//CE_Desc_End

//+++++++++++ TMargin

//CE_Desc_Begin(TMargin)
{Auxiliary class for saving margin (gutter information).  There is no need to create instances of this class.}
//CE_Desc_End
//CE_Desc_Begin(TMargin.Width)
{Width of the Margin}
//CE_Desc_End
//CE_Desc_Begin(TMargin.MarginType)
{Margin Type}
//CE_Desc_End
//CE_Desc_Begin(TMargin.Assign)
{Assigns the settings from 'Source' to this object.}
//CE_Desc_End
//+++++++++++ TDivOptions

//CE_Desc_Begin(TDivOptions.ViewWSpace)
{
White space can be made visible which may useful for languages in which white space is significant, such as Python. Space characters appear as small centred dots and tab characters as light arrows pointing to the right. There are also ways to control the display of end of line characters. The two messages set and get the white space display mode. 
See Scintilla Documentation for more info.}
//CE_Desc_End
//CE_Desc_Begin(TDivOptions)
{Assorted options}
//CE_Desc_End
//CE_Desc_Begin(TDivOptions.UsePalette)
{On 8 bit displays, which can only display a maximum of 256 colours, the graphics environment mediates between the colour needs of applications through the use of palettes.}
//CE_Desc_End
//CE_Desc_Begin(TDivOptions.OverType)
{When OverType is True, each typed character replaces the character to the right of the text caret. When overtype is disabled, characters are inserted at the caret.}
//CE_Desc_End
//CE_Desc_Begin(TDivOptions.ViewEOL)
{If true Displays the EOL characters.}
//CE_Desc_End
//CE_Desc_Begin(TDivOptions.EndAtLastLine)
{Sets the scroll range so that maximum scroll position has the last line at the bottom of the view (default). Setting this to false allows scrolling one page below the last line.}
//CE_Desc_End
//CE_Desc_Begin(TDivOptions.ScrollBarH)
{If True then the Horizontal Scrollbar are visible}
//CE_Desc_End
//CE_Desc_Begin(TDivOptions.ScrollBarV)
{If True then the Vertical Scrollbar are visible}
//CE_Desc_End
//CE_Desc_Begin(TDivOptions.Assign)
{Assigns the settings from 'Source' to this object.}
//CE_Desc_End

//+++++++++++ TCaret

//CE_Desc_Begin(TCaret)
{Options for the Caret}
//CE_Desc_End
//CE_Desc_Begin(TCaret.ForeColor)
{Foreground color for the Caret.}
//CE_Desc_End
//CE_Desc_Begin(TCaret.LineBackColor)
{Line background for the current line. Only active when LineVisible are True}
//CE_Desc_End
//CE_Desc_Begin(TCaret.LineVisible)
{If true then the current line gets the <%LINK TCaret.LineBackColor,LineBackColor%> color}
//CE_Desc_End
//CE_Desc_Begin(TCaret.Width)
{Width of the Caret}
//CE_Desc_End
//CE_Desc_Begin(TCaret.Period)
{The period between blinks of the charet.. Default: 500}
//CE_Desc_End
//CE_Desc_Begin(TCaret.Assign)
{Assigns the settings from 'Source' to this object.}
//CE_Desc_End

//+++++++++++ TSciColors

//CE_Desc_Begin(TSciColors)
{Internal class}
//CE_Desc_End
//CE_Desc_Begin(TSciColors.SelFore)
{Selection Foreground color.}
//CE_Desc_End
//CE_Desc_Begin(TSciColors.SelBack)
{Selection Background color.}
//CE_Desc_End
//CE_Desc_Begin(TSciColors.MarkerFore)
{Marker foreground color}
//CE_Desc_End
//CE_Desc_Begin(TSciColors.MarkerBack)
{Marker background color}
//CE_Desc_End
//CE_Desc_Begin(TSciColors.FoldHi)
{Fold margin hilight color}
//CE_Desc_End
//CE_Desc_Begin(TSciColors.FoldLo)
{Fold margin color}
//CE_Desc_End
//CE_Desc_Begin(TSciColors.BookMarkBack)
{Background color for bookmarks}
//CE_Desc_End
//CE_Desc_Begin(TSciColors.BookMarkFore)
{Foreground color for bookmarks}
//CE_Desc_End
//CE_Desc_Begin(TSciColors.Assign)
{Assigns the settings from 'Source' to this object.}
//CE_Desc_End

//+++++++++++ TSciHotSpot

//CE_Desc_Begin(TSciHotSpot.SingleLine)
{If True, stops a hotspot from wrapping onto next line.}
//CE_Desc_End
//CE_Desc_Begin(TSciHotSpot.Underlined)
{If True, a underline is drawn when the mouse hovers over the hotspot.}
//CE_Desc_End
//CE_Desc_Begin(TSciHotSpot.ForeColor)
{Foreground color when the mouse hovers over the hotspot.<%SEEALSO BackColor%>}
//CE_Desc_End
//CE_Desc_Begin(TSciHotSpot.BackColor)
{Background color when the mouse hovers over the hotspot.<%SEEALSO ForeColor%>}
//CE_Desc_End
//CE_Desc_Begin(TSciHotSpot.Assign)
{Assigns the settings from 'Source' to this object.}
//CE_Desc_End

//+++++++++++ TScintillaMemo

//CE_Desc_Begin(TScintilla)
{Adds more functionality than <%LINK TScintillaBase%>, such as syntax highlightning,
more exposed properties and events etc.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.OnHotSpotClick)
{Fired when the user clicks on text that is in a style with the hotspot attribute set. This notification can be used to link to variable definitions or web pages. The position field is set the text position of the click or double click and the modifiers field set to the key modifiers held down.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.OnHotSpotDoubleClick)
{Fired when the user doubleclicks on text that is in a style with the hotspot attribute set. This notification can be used to link to variable definitions or web pages. The position field is set the text position of the click or double click and the modifiers field set to the key modifiers held down.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.OnStyleNeeded)
{Event handler triggered each time text needs styling for display if the Lexer language is set to 'container'}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.OnCharAdded)
{Event handler triggered when chars are added to the text buffer.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.OnSavePointReached)
{Event handler triggered when the save point is reached, allowing the container to hide a "document dirty" indicator and change its menus.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.OnSavePointLeft)
{Event handler triggered when the save point is left, allowing the container to display a "document dirty" indicator and change its menus.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.OnModifyAttemptRO)
{Event handler triggered when the user tries to modify a read-only buffer.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.OnDoubleClick)
{Event handler triggered when the user double clicks on control.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.OnUpdateUI)
{Event handler triggered  when either the text or styling of the document has changed or the selection range has changed. It is a good place to update any container UI elements that depend on document or view state.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.OnModified)
{Event handler triggered when the text or the styling of the text buffer changes.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.OnMacroRecord)
{Event handler triggered whenever a recordable change occurs while marco recording is on.  It is up to the programmer to save the recorded action.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.OnMarginClick)
{Event handler triggered when the user clicks on the margins (gutters)}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.OnNeedShown)
{Event handler triggered when a range of lines that is currently invisible should be made visible. An example of where this may be needed is if the end of line of a contracted fold point is deleted.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.OnPainted)
{Event handler triggered when painting has just been done.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.OnUserListSelection)
{Event handler triggered when the user has selected an item in a user list. }
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.OnDwellStart)
{Fired when the user keeps the mouse in one position for the dwell period.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.OnDwellEnd)
{Fired after a <%LINK TScintillaBase.OnDwellStart,OnDwellStart%> and the mouse is moved or other activity such as key press indicates the dwell is over.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.OnZoom)
{Event handler triggered  when the user zooms the display using the keyboard or <%LINK TScintillaBase.SetZoom,SetZoom%> method is called.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.OnCallTipClick)
{Event handler triggered when the user clicks on calltip.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.OnMsgSent)
{When the property Dummy is set this event handler is called for every message that would be sent to the Scintilla contro otherwise.  Can be used for debugging purposes.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.OnKeyUp)
{See the Delphi Help for information on this property}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.OnKeyDown)
{See the Delphi Help for information on this property}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.OnKeyPress)
{See the Delphi Help for information on this property}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.AutoAdjustLineNumberWidth)
{This function autoadjusts the Gutter0 width to fit the width to print the highest linenumber so far.

Minimum is 4 characters worth.
You can use this in the <%LINK TScintillaBase.OnModified,OnModified%> event to autoadjusts as you go.
}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.ActiveHotSpot)
{Defines colors etc to be used when the mouse hovers over a hotspot.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.doSciCharAdded)
{Implements indentation management, and calls CharAddedAutoComplete. <%SEEALSO TScintillaBase.doSciCharAdded%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.doSciMarginClick)
{Handles folding etc. <%SEEALSO TScintillaBase.doSciMarginClick%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.doSciModified)
{Handles folding etc. <%SEEALSO TScintillaBase.doSciModified%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.doSciUpdateUI)
{Handles bracematching. <%SEEALSO TScintillaBase.doSciUpdateUI%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.doSciUserListSelection)
{Not implemented yet. Just calls it's parent. <%SEEALSO TScintillaBase.doSciUserListSelection%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.CopyFrom)
{Copies settings from 'Source' to this.}
//CE_Desc_End
//CE_Desc_Begin(TScintilla.ExportToHTML)
{Exports the current document to HTML, with the styling used in the editor.
'Stream' is the stream to export to, and 'Title' is the title the exported file should have.
}
//CE_Desc_End
//CE_Desc_Begin(TScintilla.LoadLexerLibrary)
{Loads an external lexer library and Adds all contained lexers to the lexerlist used in
the Optionsdialog.
}
//CE_Desc_End
//CE_Desc_Begin(TScintilla.LibrariesLoaded)
{The list of external lexer libraries loaded. It's maintained here to not reload an already loaded lexer.}
//CE_Desc_End

//CE_Desc_Begin(TScintillaMemo.AddCallTipClickHandler)
{Register a handler in a component/other to receive the <%LINK TScintillaBase.OnCallTipClick%> when it fires.
Use it like this:
Declare a variable of the TSciCallTipClickProc class inside the class that'll use it.
Instantiate it:

nameofvar.Create(nameoftheeventhandler);
Call AddCallTipClickHandler(nameofvar);
}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.RemoveCallTipClickHandler)
{Removes a previously added handler.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.AddCharAddedHandler)
{Register a handler in a component/other to receive the <%LINK TScintillaBase.OnCharAdded%> when it fires.
Use it like this:
Declare a variable of the TSciCharAddedProc class inside the class that'll use it.
Instantiate it:

nameofvar.Create(nameoftheeventhandler);
Call AddCharAddedHandler(nameofvar);}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.RemoveCharAddedHandler)
{Removes a previously added handler.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.AddMacroRecordHandler)
{Register a handler in a component/other to receive the <%LINK TScintillaBase.OnMacroRecord%> when it fires.
Use it like this:
Declare a variable of the TSciMacroRecordProc class inside the class that'll use it.
Instantiate it:

nameofvar.Create(nameoftheeventhandler);
Call AddMacroRecordHandler(nameofvar);}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.RemoveMacroRecordHandler)
{Removes a previously added handler.}
//CE_Desc_End


//CE_Desc_Begin(TScintillaMemo.MaintainIndentation)
{Checks the char 'ch', and if it receives a newline (based on the current <%LINK TScintillaMemo.EOLStyle,EOLStyle%>),
maintains the same indentation as the line above.
Called by <%LINK TScintillaMemo.doSciCharAdded%> when <%LINK TScintillaMemo.Indentation,Indentation%> includes KeepIndent.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.CharAddedAutoComplete)
{Introduced here so derived classes can implement autocompletion relatively
simple, without adding so much code. Empty in this class, but implemented in
TScintillaAuto.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.DefineMarker)
{Define a new marker.
MarkNum: Marker number
Marker: Marker Symbols}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.FindMatchingBracePosition)
{Find if there is a brace next to the caret, checking before caret first, then
after caret. If brace found also find its matching brace.
returns true if inside a bracket pair.
}
//CE_Desc_End

//CE_Desc_Begin(TScintillaMemo.Indentation)
{See Scintilla Documentation for more info.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.AutoCloseBraces)
{Closes the following chars when entered, i.e in addition to add the brace, it also adds it's opposite:
( [ {
}
//CE_Desc_End

//CE_Desc_Begin(TScintillaMemo.AutoCloseQuotes)
{Closes the following chars when entered, i.e in addition to add the quote, it also adds it's opposite:
' "
}
//CE_Desc_End

//CE_Desc_Begin(TScintillaMemo.Gutter0)
{Scintilla provides up to three different margins (also called gutters).  The first one (Gutter0) is typically used for showing line numbers, the last one (Gutter2) for code-folding and the other one (Gutter1) for other purposes (bookmarks, debugging etc.).

To set the colors if this is a LineNumber gutter, set the StyleNumber 33 (predefined for all languages) to the colors you want.
This also set the background color for all margins which doesn't have any folding symbols.

To set the color for the folding margin, set the <%LINK TSciColors.FoldHi%>, and <%LINK TSciColors.FoldLo%>.
To set the color for markers, set the <%LINK TSciColors.MarkerFore%>, and <%LINK TSciColors.MarkerBack%>.
To set the color for bookmarks (a predefined marker), set the <%LINK TSciColors.BookMarkFore%>, and <%LINK TSciColors.BookMarkBack%>.

This property allows the user to set the width and style of the first gutter.
<%SEEALSO TMargin%><%SEEALSO TMargin.MarginType%><%SEEALSO TMargin.Width%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.Gutter1)
{Scintilla provides up to three different margins (also called gutters).  The first one (Gutter0) is typically used for showing line numbers, the last one (Gutter2) for code-folding and the other one (Gutter1) for other purposes (bookmarks, debugging etc.).

To set the colors if this is a LineNumber gutter, set the StyleNumber 33 (predefined for all languages) to the colors you want.
This also set the background color for all margins which doesn't have any folding symbols.

To set the color for the folding margin, set the <%LINK TSciColors.FoldHi%>, and <%LINK TSciColors.FoldLo%>.
To set the color for markers, set the <%LINK TSciColors.MarkerFore%>, and <%LINK TSciColors.MarkerBack%>.
To set the color for bookmarks (a predefined marker), set the <%LINK TSciColors.BookMarkFore%>, and <%LINK TSciColors.BookMarkBack%>.

This property allows the user to set the width and style of the first gutter.
<%SEEALSO TMargin%><%SEEALSO TMargin.MarginType%><%SEEALSO TMargin.Width%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.Gutter2)
{Scintilla provides up to three different margins (also called gutters).  The first one (Gutter0) is typically used for showing line numbers, the last one (Gutter2) for code-folding and the other one (Gutter1) for other purposes (bookmarks, debugging etc.).

To set the colors if this is a LineNumber gutter, set the StyleNumber 33 (predefined for all languages) to the colors you want.
This also set the background color for all margins which doesn't have any folding symbols.

To set the color for the folding margin, set the <%LINK TSciColors.FoldHi%>, and <%LINK TSciColors.FoldLo%>.
To set the color for markers, set the <%LINK TSciColors.MarkerFore%>, and <%LINK TSciColors.MarkerBack%>.
To set the color for bookmarks (a predefined marker), set the <%LINK TSciColors.BookMarkFore%>, and <%LINK TSciColors.BookMarkBack%>.

This property allows the user to set the width and style of the first gutter.
<%SEEALSO TMargin%><%SEEALSO TMargin.MarginType%><%SEEALSO TMargin.Width%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.WordWrapVisualFlags)
{You can enable the drawing of visual flags to indicate a line is wrapped.
Bits set in WordWrapVisualFlags determine which visual flags are drawn.

sciWWEnd:  Visual flag at end of subline of a wrapped line.
sciWWStart: Visual flag at begin of subline of a wrapped line.

Subline is indented by at least 1 to make room for the flag}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.WordWrapVisualFlagsLocation)
{You can set wether the visual flags to indicate a line is wrapped are drawn near the border or near the text. Bits set in wrapVisualFlagsLocation set the location to near the text for the corresponding visual flag.

Default (none selected): Visual flags drawn near border
sciEndByText:  Visual flag at end of subline drawn near text
sciStartByText: Visual flag at begin of subline drawn near text}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.LayoutCache)
{sciCacheType=(sciCacheNone,sciCacheCaret,sciCachePage,sciCacheDocument);

See Scintilla Documentation for more info.
}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.EdgeMode)
{Get/Set the mode used to display long lines. It can be one of the following:

sciEdgeNone: Long lines are not marked. This is the default state.
sciEdgeLine: A vertical line is drawn at the column number set by <%LINK TScintillaMemo.EdgeColumn%>. This works well for monospaced fonts. The line is drawn at a position based on the width of a space character in the default font (Style 32, or Font property), so it may not work very well if your styles use proportional fonts or if your style have varied font sizes or you use a mixture of bold, italic and normal text.
sciEdgeBackground: The background colour of characters after the column limit is changed to the color set by <%LINK TScintillaMemo.EdgeColor%>. This is recommended for proportional fonts.
}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.EdgeColumn)
{Set/Get the column number at which to display the long line marker.
When drawing lines, the column sets a position in units of the width of a space character in the default font (Style 32, or Font property). When setting the background color, the column is a character count (allowing for tabs) into the line.}
//CE_Desc_End

//CE_Desc_Begin(TScintillaMemo.BookmarkAdd)
{Add bookmark ar line 'lineno'. If lineno=-1 then the current line is used.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.BookmarkDelete)
{Remove the bookmark at line 'lineno'. If lineno=-1 then the current line is used.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.BookmarkToggle)
{Toggles the bookmark at line 'lineno'. If lineno=-1 then the current line is used.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.BookmarkPresent)
{Tests if it's a bookmark at the line 'lineno'. If lineno=-1 then the current line is used. Returns true if so.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.BookmarkNext)
{Go to next bookmark. If forwardscan=false then searches backwards}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.Lines)
{Provides familiar Delphi access to the Text of the control.  If UseUnicode is True then the text is in UTF8.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.EOLStyle)
{TEOLStyle=(eolCRLF, eolCR, eolLF);

End of line style.
}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.IndentWidth)
{Indent width in characters.  If 0 the TabWidth is used instead.<%SEEALSO TScintillaMemo.TabWidth,TabWidth%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.KeyCommands)
{A collection of Keyboard commands.  Customise at design time or at run time with the provided property editor or the options dialogbox.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.MarginLeft)
{Left margin in pixels.  (The distance between the text and the gutter).}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.MarginRight)
{Right margin in pixels.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.TabWidth)
{The Tab width in characters.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.ReadOnly)
{Set to true to make the text buffer read-only.
Remember, can't set the text by code either when it's true.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.UseTabs)
{If false tab characters are replaced by spaces.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.Caret)
{<%LINK TCaret,Caret Properties%>}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.DivOptions)
{Assorted Options}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.Colors)
{Assorted color settings.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.MouseDwellTime)
{Set/get the time the mouse must sit still, in milliseconds, to generate a <%LINK TScintillaBase.OnDwellStart%> event. If set to SC_TIME_FOREVER, the default, no dwell events are generated.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.ClearUndoAfterSave)
{If True, clears the undobuffer when the document is saved.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.HideSelect)
{The normal state is to make the selection visible by drawing it as set by <%LINK TSciColors.SelFore,Colors.SelFore%> and <%LINK TSciColors.SelBack,Colors.SelBack%>. However, if you hide the selection, it is drawn as normal text.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.WordWrap)
{Enable/Disable WordWrapping}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.EdgeColor)
{Set and get the color of the marker used to show that a line has exceeded the length set by <%LINK TScintillaMemo.EdgeColumn%>.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.WordChars)
{List of chars that's part of a word. Used by autocomplete etc.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.StripTrailingSpaces)
{Removes all trailing spaces from the lines.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.LengthOfIndicator)
{Returns the length of the indicator 'indicatorNumber', which is at position 'atPos'.

<%NOTE%>
'indicatorNumber' can be either the number of the indicator (0-2), OR
a indicatormask.
}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.LocateIndicator)
{Searches for the indicator 'indicatorNumber', starting from the position 'startSearchAtPos'.

<%NOTE%>
'indicatorNumber' can be either the number of the indicator (0-2), OR
a indicatormask.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.ShowIndicatorAt)
{Display/Hide the indicator 'indicatorNumber' starting from the position 'atPos' for 'Length' characters.
<%NOTE%>
'indicatorNumber' can be either the number of the indicator (0-2), OR
a indicatormask.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaMemo.RemoveIndicator)
{Removes the indicator 'indicatorNumber' which is at 'atPos'.
<%NOTE%>
'indicatorNumber' can be either the number of the indicator (0-2), OR
a indicatormask.}
//CE_Desc_End


// ---------------- TSCINTILLA
//CE_Desc_Begin(SciLexerMod.pas)
{The TScintilla component, more exposure of properties etc.}
//CE_Desc_End

//CE_Desc_Begin(TScintilla.FoldMarkerType)
{Folding marker type, can be one of:
sciMarkCircle,sciMarkBox,sciMarkPlusMinus or sciMarkArrows}
//CE_Desc_End
//CE_Desc_Begin(TScintilla.LanguageManager)
{Set the syntax highlighter for the editing control and associated keywords,styles, commentingstyles etc.}
//CE_Desc_End
//CE_Desc_Begin(TScintilla.CommentStream)
{Comments or Uncomments a selection (or if no selection is made, a word) with the starting and ending character(s)
defined in the <%LINK TSciLangItem.CommentBoxStart,CommentBoxStart%> and <%LINK TSciLangItem.CommentBoxEnd,CommentBoxEnd%>
properties of the current language.

If 'includecommentcharsinselection' is True, then the selection when finished includes the commentingchars,
if not it don't.

If the commenting is already in place, then it uncomments it.}
//CE_Desc_End
//CE_Desc_Begin(TScintilla.CommentBlock)
{Comments the selected text with a block comment.

Inserts the comment mark defined for the <%LINK TSciLangItem.CommentBlock,CommentBlock%>
property in the selected <%LINK TSciLangItem,language%> at the start of each line that is marked.

If none are marked, just comments the current line.
If the commenting is already in place, then it uncomments it.
}
//CE_Desc_End
//CE_Desc_Begin(TScintilla.CommentBox)
{Comments the selected text with a box comment.

Inserts the comment marks defined for the <%LINK TSciLangItem.CommentBoxStart,CommentBoxStart%>, <%LINK TSciLangItem.CommentBoxMiddle,CommentBoxMiddle%>, <%LINK TSciLangItem.CommentBoxEnd,CommentBoxEnd%>
properties in the selected <%LINK TSciLangItem,language%> in the following place:

<%LINK TSciLangItem.CommentBoxStart,CommentBoxStart%> starts the comment.
<%LINK TSciLangItem.CommentBoxMiddle,CommentBoxMiddle%> are inserted for each of the middle lines
<%LINK TSciLangItem.CommentBoxEnd,CommentBoxEnd%> are inserted at the end.

If 'includecommentcharsinselection' is True, then the selection when finished includes the commentingchars,
if not it don't.

If none are marked, just comments the current line. (uses only CommentBoxStart and CommentBoxEnd).
If the commenting is already in place, then it uncomments it.
}
//CE_Desc_End
//CE_Desc_Begin(TScintilla.StreamComment)
{Comments/Uncomments the selection (or the current word if none was made) with
'start_comment' at the start, and 'end_comment' at the end.

If 'includecommentcharsinselection' is True, then the selection when finished includes the commentingchars,
if not it don't.}
//CE_Desc_End
//CE_Desc_Begin(TScintilla.BoxComment)
{Comments/Uncomments the selection (or the current line if none was made) with
'start_comment' at the start, 'middle_comment' at the start of each line,
and 'end_comment' at the end.

If 'includecommentcharsinselection' is True, then the selection when finished includes the commentingchars,
if not it don't.

<%NOTE%>
This operates only on whole lines.}
//CE_Desc_End
//CE_Desc_Begin(TScintilla.BlockComment)
{Comments/Uncomments the selection (or the current line if none was made) with
'start_comment' at the start of each line.

If 'commentatlinestart' is False commenting characters are inserted after any indentation,
else it is inserted at the start of the line.

<%NOTE%>
This operates only on whole lines.}
//CE_Desc_End

//CE_Desc_Begin(TScintilla.FlipVars)
{Swaps a variable and a value with eachother.

This is something that I use a lot really.. Just study the EdOptionsWin.Pas and you'll see that.

Parameter               Use
equalsign               The character the language uses as it's equal sign. Default: =
spacebeforeandaftereq   True if it should be one space before and after the equal sign. Default: True
endstatement            The character (or more) that signifies end of a statement. Default: ;

<%BOLD%>Example:<%TEXT%>
If you have these lines in your code:

<%CODE%>variable=TestData;

<%TEXT%>After this command is ran with the following command: <%CODE%>FlipVars;<%TEXT%> it would read:

<%CODE%>TestData=variable;<%TEXT%>

<%NOTE%>
If you have made a selection then the function will search for, and flip each and every variable that matches inside the selection.
If no selection is made, it selects the current line and flips each and every on that one line.
}
//CE_Desc_End
//CE_Desc_Begin(TScintilla.Expand)
{Expand/Collapse fold(s).}
//CE_Desc_End

//CE_Desc_Begin(TScintilla.FoldAll)
{Fold all code blocks.}
//CE_Desc_End
//CE_Desc_Begin(TScintilla.BraceHilite)
{If true the editor performs brace highlighting i.e. when the cursor is a brance ([,(,{) the matching braces are highlighted.  It is True by default.}
//CE_Desc_End
//CE_Desc_Begin(TScintilla.Folding)
{If the foldFold flag is set to True the editor shows the code folding gutter with codefolding symbols if the active highlighter supports codefolding.

Flag                   Function
foldFold               This enables/disables folding. The rest of the flags below doesn't do anything unless this is enabled
foldCompact            For HTML, XML, Lua and C++ and similar files, turning this option on leads to blank lines following the end of an element folding with that element. Defaults to on.
foldComment            This option enables folding multi-line comments when using the C++ lexer and possibly other lexers.
foldAtElse             This option enables C++ folding on a "} else {" line of an if statement.
foldPreprocessor       This option enables folding preprocessor directives when using the C++ lexer. Includes C#'s explicit #region and #endregion folding directives.
foldCommentPython      This option enable folding of multi-line comments in Python
foldQuotesPython       This enable folding of quoted strings when using the Python lexer.
foldHTML               Folding is turned on or off for HTML and XML files with this option. The fold option must also be on for folding to occur.
foldHTMLPreProcessor   Enables HTML preprocessor folding}
//CE_Desc_End
//CE_Desc_Begin(TScintilla.GoMatchingBrace)
{Move carret to matching brace.}
//CE_Desc_End









//----------- SciLexerOptionsDlg.pas
//CE_Desc_Begin(SciLexerOptionsDlg.pas)
{Contains a component that wraps a dialog for setting various options of the Scintilla edit control, inluding syntax highlighting and keyboard commands.  Add it to your form and then you just need to call its Execute method.}
//CE_Desc_End

//+++++++++++ TScintillaOptionsDlg

//CE_Desc_Begin(TScintillaOptionsDlg)
{Optionsdialog for the TScintilla derived classes.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaOptionsDlg.Execute)
{Displays the Options dialog.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaOptionsDlg.Editor)
{Set this property to the TScintilla derived component to attach to.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaOptionsDlg.Pages)
{OptionPages to display.}
//CE_Desc_End
//CE_Desc_Begin(TScintillaOptionsDlg.ActivePage)
{The currently active page.}
//CE_Desc_End

//----------- ScintillaLanguageManager.Pas
//CE_Desc_Begin(ScintillaLanguageManager.pas)
{TODO:DESCRIBE THIS UNIT!}
//CE_Desc_End

//+++++++++++ TLexerNamesMap


//CE_Desc_Begin(SameStyle)
{Returns True if Style1 and Style2 is exactly equal, except Name and StyleNumber}
//CE_Desc_End

//+++++++++++ TSciKeywords

//CE_Desc_Begin(TSciKeywords)
{Keywords for the lexer/language}
//CE_Desc_End
//CE_Desc_Begin(TSciKeywords.KeywordListNumber)
{The keyword list number. Check with the LexXXX.cxx in the scintilla source
to find the list numbers for the lexer you chose.}
//CE_Desc_End
//CE_Desc_Begin(TSciKeywords.Name)
{The name of the keyword list, default are keywords[xx].}
//CE_Desc_End
//CE_Desc_Begin(TSciKeywords.Keywords)
{Keywords.

<%NOTE%>
It seems that if you start a keyword with a ^, then the keyword is treated as a prefix.
i.e if you define ^WIN as a keyword, then WINWHATEVER will also be treated as a keyword.}
//CE_Desc_End
//CE_Desc_Begin(TSciKeywords.AssignRec)
{Fill from a <%FLINK TSciLangKeywords,TSciLangKeywords%> record.}
//CE_Desc_End
//CE_Desc_Begin(TSciKeywords.AssignToRec)
{Assign to a <%FLINK TSciLangKeywords,TSciLangKeywords%> record.}
//CE_Desc_End
//CE_Desc_Begin(TSciKeywords.Assign)
{Assigns the settings from 'Source' to this object.}
//CE_Desc_End

//+++++++++++ TSciStyle
//CE_Desc_Begin(TSciStyle)
{A style.

For each style you can set the font name, size and use of bold, italic and underline, foreground and background colour and the character set. You can also choose to hide text with a given style, display all characters as upper or lower case and fill from the last character on a line to the end of the line (for embedded languages). There is also an experimental attribute to make text read-only.

It is entirely up to you (and the lexer) how you use styles.
If you want to use syntax colouring you might use style 0 for white space, style 1 for numbers, style 2 for keywords, style 3 for strings, style 4 for preprocessor, style 5 for operators, and so on.
}
//CE_Desc_End
//CE_Desc_Begin(TSciStyle.FontName)
{Font to be used}
//CE_Desc_End
//CE_Desc_Begin(TSciStyle.FontSize)
{Size of the Font to be used}
//CE_Desc_End
//CE_Desc_Begin(TSciStyle.FontStyles)
{The styles for the font to be used.}
//CE_Desc_End
//CE_Desc_Begin(TSciStyle.ForeColor)
{The color of the font}
//CE_Desc_End
//CE_Desc_Begin(TSciStyle.BackColor)
{Background color for this style}
//CE_Desc_End
//CE_Desc_Begin(TSciStyle.CharSet)
{CharSet for this style. Use -1 to not set any other than the main charset for the control.}
//CE_Desc_End
//CE_Desc_Begin(TSciStyle.CharCase)
{TSciCase = (CASE_MIXED = 0,CASE_UPPER = 1,CASE_LOWER = 2);

The case for the current style.
}
//CE_Desc_End
//CE_Desc_Begin(TSciStyle.Visible)
{Text is normally visible.
However, you can completely hide it by giving it a style with the visible set to 0.
This could be used to hide embedded formatting instructions or hypertext keywords in HTML or XML.}
//CE_Desc_End
//CE_Desc_Begin(TSciStyle.Hotspot)
{If true, then it's a hotspot.}
//CE_Desc_End
//CE_Desc_Begin(TSciStyle.Name)
{Name of the style}
//CE_Desc_End
//CE_Desc_Begin(TSciStyle.StyleNumber)
{The stylenumber this definition are for. Check scilexer.h or scintilla.iface for
stylenumbers for the different lexers.

<%BOLD%><%ITALIC%><%RED%>PREDEFINED Stylenumber constants<%BLACK%><%TEXT%>

<%BOLD%>STYLE_DEFAULT = 32<%TEXT%>

This style defines the attributes that all styles receive when the <%LINK TScintillaBase.StyleClearAll,StyleClearAll%> is used.

<%BOLD%>STYLE_LINENUMBER = 33<%TEXT%>

This style sets the attributes of the text used to display line numbers in a line number margin.
The background colour set for this style also sets the background colour for all margins that do
not have any folding mask bits set. That is, any margin for which mask & SC_MASK_FOLDERS is 0.
See <%LINK TScintillaBase.SetMarginMaskN,SetMarginMaskN%> for more about masks.

<%BOLD%>STYLE_BRACELIGHT = 34<%TEXT%>

This style sets the attributes used when highlighting braces with the <%LINK TScintillaBase.BraceHighlight,BraceHighlight%>
and when highlighting the corresponding indentation with <%LINK TScintillaBase.SetHighlightGuide,SetHighlightGuide%>.

<%BOLD%>STYLE_BRACEBAD = 35<%TEXT%>

This style sets the display attributes used when marking an unmatched brace with the <%LINK TScintillaBase.BraceBadLight,BraceBadLight%>.

<%BOLD%>STYLE_CONTROLCHAR = 36<%TEXT%>

This style sets the font used when drawing control characters.
Only the font, size, bold, italics, and character set attributes are used and not the colour attributes.

<%BOLD%>STYLE_INDENTGUIDE = 37<%TEXT%>

This style sets the foreground and background colours used when drawing the indentation guides.

<%BOLD%>STYLE_LASTPREDEFINED = 39<%TEXT%>

To make it easier for client code to discover the range of styles that are predefined, this is
set to the style number of the last predefined style.
This is currently set to 39 and the last style with an identifier is 37, which reserves space
for future predefined styles.

<%BOLD%>STYLE_MAX = 127<%TEXT%>

This is not a style but is the number of the maximum style that can be set.
Styles between STYLE_LASTPREDEFINED and STYLE_MAX would be appropriate if you used SCI_SETSTYLEBITS
to set more than 5 style bits.
}
//CE_Desc_End
//CE_Desc_Begin(TSciStyle.Changeable)
{This is an experimental and incompletely implemented style attribute.
The default setting is changeable set true but when set false it makes text read-only.
Currently it only stops the caret from being within not-changeable text and does not yet stop deleting a range that contains not-changeable text.}
//CE_Desc_End
//CE_Desc_Begin(TSciStyle.EOLFilled)
{If the last character in the line has a style with this attribute set, the remainder of the line up to the right edge of the window is filled with the background colour set for the last character.
This is useful when a document contains embedded sections in another language such as HTML pages with embedded JavaScript.
By setting EOLFilled to True and a consistent background colour (different from the background colour set for the HTML styles) to all JavaScript styles then JavaScript sections will be easily distinguished from HTML.}
//CE_Desc_End
//CE_Desc_Begin(TSciStyle.AssignRec)
{Fill from a <%FLINK TSciLangStyle,TSciLangStyle%> record.}
//CE_Desc_End
//CE_Desc_Begin(TSciStyle.AssignToRec)
{Assign to a <%FLINK TSciLangStyle,TSciLangStyle%> record.}
//CE_Desc_End
//CE_Desc_Begin(TSciStyle.Assign)
{Assigns the settings from 'Source' to this object.}
//CE_Desc_End

//+++++++++++ TSciKeyWordsList

//CE_Desc_Begin(TSciKeyWordsList)
{Internal class for handling keywordlists}
//CE_Desc_End

//+++++++++++ TSciStyleList
//CE_Desc_Begin(TSciStyleList)
{List of <%LINK TSciStyle,styles%>.}
//CE_Desc_End

//+++++++++++ TSciLangItem

//CE_Desc_Begin(TSciLangItem)
{A Language/Lexer item.}
//CE_Desc_End
//CE_Desc_Begin(TSciLangItem.Name)
{The languagename of this lexer/language. Default: Language[xxx]
}
//CE_Desc_End
//CE_Desc_Begin(TSciLangItem.Styles)
{The <%LINK TSciStyleList,list of styles%> for this language.}
//CE_Desc_End
//CE_Desc_Begin(TSciLangItem.Keywords)
{<%LINK TSciKeyWordsList,Keywordslists%> for the language/lexer.}
//CE_Desc_End
//CE_Desc_Begin(TSciLangItem.Lexer)
{The lexer to be used for this language.}
//CE_Desc_End
//CE_Desc_Begin(TSciLangItem.Assign)
{Assigns the settings from 'Source' to this object.}
//CE_Desc_End
//CE_Desc_Begin(TSciLangItem.CommentAtLineStart)
{If true, the commenting for <%LINK TScintilla.CommentBlock%> is inserted at the start of line,
else it's inserted after indents and such on the line.

Default: True
}
//CE_Desc_End
//CE_Desc_Begin(TSciLangItem.CommentBoxEnd)
{The end part for a box comment. Default: */

Used by <%LINK TScintilla.CommentBox%>}
//CE_Desc_End
//CE_Desc_Begin(TSciLangItem.CommentBoxStart)
{The start part for a box comment. Default: /*

Used by <%LINK TScintilla.CommentBox%>}
//CE_Desc_End
//CE_Desc_Begin(TSciLangItem.CommentBoxMiddle)
{The middle part for a box comment. Default: *

Used by <%LINK TScintilla.CommentBox%>}
//CE_Desc_End

//CE_Desc_Begin(TSciLangItem.CommentBlock)
{The marker for a oneline comment. Default: *

Used by <%LINK TScintilla.CommentBlock%>}
//CE_Desc_End
//CE_Desc_Begin(TSciLangItem.CommentStreamStart)
{The start symbol/string for a stream comment. Default: /*

Used by <%LINK TScintilla.CommentStream%>}
//CE_Desc_End
//CE_Desc_Begin(TSciLangItem.CommentStreamEnd)
{The start symbol/string for a stream comment. Default: /*

Used by <%LINK TScintilla.CommentStream%>}
//CE_Desc_End

//CE_Desc_Begin(TSciLangItem.AssignmentOperator)
{The assignmentoperator for the language. Default: =

Used by <%LINK TScintilla.FlipVars%>}
//CE_Desc_End
//CE_Desc_Begin(TSciLangItem.EndOfStatementOperator)
{The symbol/string which marks an end of statement. Default: ;

Used by <%LINK TScintilla.FlipVars%>}
//CE_Desc_End

//CE_Desc_Begin(TSciLangItem.ExtraData)
{Extra data for this language.. See <%LINK TSciLanguageManager.ExtraData%>}
//CE_Desc_End


//+++++++++++ TSciLangList

//CE_Desc_Begin(TSciLangList)
{List of languages/lexers.}
//CE_Desc_End
//CE_Desc_Begin(TSciLangList.Select)
{Selects the language 'fLanguage' as the active for the editor.}
//CE_Desc_End
//CE_Desc_Begin(TSciLangList.Find)
{Locates the language 'fLanguage' and returns it. If not found, returns NULL.}
//CE_Desc_End
//CE_Desc_Begin(TSciLangList.GetStyleList)
{Locates the language 'fLanguage' and returns it. If not found, creates a
stylelist containing the NULL styles, and returns it.
If the language/lexerdefinition does'nt exists, it's created that is.}
//CE_Desc_End

//+++++++++++ TSciLanguageManager

//CE_Desc_Begin(TSciLanguageManager)
{Syntax Lexer Class.}
//CE_Desc_End
//CE_Desc_Begin(TSciLanguageManager.LanguageList)
{List of the defined languages/lexers and their keywords/styles. <%SEEALSO TSciLangList%>}
//CE_Desc_End
//CE_Desc_Begin(TSciLanguageManager.SelectedLanguage)
{Set/Get the selected language/lexer.

There are two special lexers:
Lexer      Purpose
null       No syntax highlighting
container  The container manages all styling.}
//CE_Desc_End
//CE_Desc_Begin(TSciLanguageManager.OnLanguageChanged)
{Fired when another language is selected.<%SEEALSO TSciLanguageManager.SelectedLanguage,SelectedLanguage%>}
//CE_Desc_End
//CE_Desc_Begin(TSciLanguageManager.OnLexUpdate)
{Fired when Update are called, so you can do additional updating.}
//CE_Desc_End
//CE_Desc_Begin(TSciLanguageManager.Assign)
{Assigns the settings from 'Source' to this object.}
//CE_Desc_End
//CE_Desc_Begin(TSciLanguageManager.GetLexerProps)
{Returns lexer.languagename properties. Used by TSciPropertyLoader.}
//CE_Desc_End
//CE_Desc_Begin(TSciLanguageManager.FillListWithLanguages)
{Used by the TEdOptionsWindow to fill the lexer/language list. 

sciLexerSelectType=(sciLexers,sciLanguages);
sciLexerSelectTypes=set of sciLexerSelectType;

If sciLexers is in the set, the lexers are added to the list 'lst'.
If sciLanguages is in the set, the defined languages are added to the list 'lst'.
}
//CE_Desc_End

//CE_Desc_Begin(TSciLanguageManager.AddLanguage)
{Add a new lexer/language.

Example: foo.AddLanguage('newlanguage','cpp'); creates a new language named
newlanguage, and says it should use the cpp lexer as the lexer.

<%RETURNS%>A TSciLangItem with the new languagedefinition.
}
//CE_Desc_End
//CE_Desc_Begin(TSciLanguageManager.DupLanguage)
{Copies the language/lexer styles/keywords from the language/lexer 'Langtocopy' to 'langname'.
if 'langname' is empty ('') then the new language has the same name. Change it in the
returned item if so. Otherwise 'langname' is the new languagename.

<%RETURNS%>A TSciLangItem with the new languagedefinition.
}
//CE_Desc_End
//CE_Desc_Begin(TSciLanguageManager.RemoveLanguage)
{Removes the language 'langtoremove'. 'notinstaticlist' contains False if the
language 'langtoremove' is in the lexerlist (and only styles/keywords has been cleared).

<%RETURNS%>True if the language 'langtoremove' was found and possibly removed.
}
//CE_Desc_End

//CE_Desc_Begin(TSciLanguageManager.AddLexer){Add's the lexer 'Lexer' at runtime if it isn't already in the lexer list.

To add lexers which is also available in the IDE, add the lexer in
MoreLexers.Inc (in the source directory)
}//CE_Desc_End

//CE_Desc_Begin(TSciLanguageManager.ExtraData){Use this as you would use Tag normally..

You can add extra data here, i.e a pointer to another
structure which contains more info for example.
}//CE_Desc_End
//CE_Desc_Begin(TSciLanguageManager.Disabled){If this is True, then the entire languagemanager is disabled,
and doesn't apply styles or anything else.}//CE_Desc_End



//CE_Desc_Begin(TSciLanguageManager.HasLexer){Returns True if the lexer 'Lexer' is in the lexerlist.}//CE_Desc_End

//CE_Desc_Begin(TSciLanguageManager.RemoveLexer){Removes the lexer 'Lexer' if it's found in the lexerlist.}//CE_Desc_End


//----------- SciFileExtensionsManager.pas
//CE_Desc_Begin(SciFileExtensionsManager.pas)
{The TExtensionMapper class maps fileextensions to the corresponding lexer or language.
}
//CE_Desc_End

//+++++++++++ TExtensionMapper

//CE_Desc_Begin(TExtensionMapper)
{Maps extensions to Lexers/languages.

<%NOTE%>Do NOT instantiate this class directly, use the <%LINK ExtMapper%> function to access it.}
//CE_Desc_End
//CE_Desc_Begin(TExtensionMapper.Create)
{Do NOT instantiate this class directly, use the <%LINK ExtMapper%> function to access it.}
//CE_Desc_End
//CE_Desc_Begin(TExtensionMapper.Destroy)
{Do NOT destroy this class directly, use the <%LINK ExtMapper%> function to access it.}
//CE_Desc_End
//CE_Desc_Begin(TExtensionMapper.FillExtensionMap)
{Fills the extensionmapper with the default extension->Language mappings.}
//CE_Desc_End
//CE_Desc_Begin(TExtensionMapper.Add)
{Maps the 'MapFromWhatExtension' fileextension to the 'ToWhatLanguage' lexer/language.
Example: foo.Add('.cpp','cpp') says that if the extension for a file is .cpp then it shall use the C++/C Language.}
//CE_Desc_End
//CE_Desc_Begin(TExtensionMapper.Remove)
{Removes the fileextension 'ExtensionToRemove' from the list.}
//CE_Desc_End
//CE_Desc_Begin(TExtensionMapper.RemoveAllWithLang)
{Removes all fileextensions which maps to 'MappedToWhatLang' from the list.}
//CE_Desc_End
//CE_Desc_Begin(TExtensionMapper.ExtensionsList)
{List of all extensionmappings.}
//CE_Desc_End

//CE_Desc_Begin(TExtensionMapper.DetectLanguage)
{Returns the Language to use with the fileextension 'ExtensionToFind' if found in map, else returns 'null'.
<%SEEALSO TExtensionMapper.Add%>}
//CE_Desc_End

//CE_Desc_Begin(TExtensionsToLanguageList.Create)
{Do NOT instantiate this class directly.}
//CE_Desc_End
//CE_Desc_Begin(TExtensionsToLanguageList.Items)
{Return the mapping at index Index.}
//CE_Desc_End
//CE_Desc_Begin(TExtensionsToLanguageList.Add)
{Create a new TExtensionItem item.}
//CE_Desc_End
//CE_Desc_Begin(TExtensionsToLanguageList.Delete)
{Deletes a TExtensionItem item.}
//CE_Desc_End
//CE_Desc_Begin(TExtensionsToLanguageList.MapLang)
{If 'CheckWith'<>nil then we check that the language is defined before
any mapping is done. If it isn't we just return.

Add all extensions in 'AllExtensions' which are separated by '<%LINK ExtensionSeparator%>' to the language 'WhatLanguage'.
}
//CE_Desc_End
//CE_Desc_Begin(TExtensionsToLanguageList.GetLangItem)
{Returns the TExtensionItem for the language 'WhatLanguage' if found,
otherwise just returns nil.}
//CE_Desc_End

//CE_Desc_Begin(TExtensionsToLanguageList.ExtensionSeparator)
{Which character separates the different extensions in the list.}
//CE_Desc_End


//CE_Desc_Begin(TExtensionItem.Language)
{Language used for these extensions.}
//CE_Desc_End
//CE_Desc_Begin(TExtensionItem.Extensions)
{Extensions mapped to this language. The list is separated by <%LINK TExtensionsToLanguageList.ExtensionSeparator%>}
//CE_Desc_End

//----------- SciPropertyMgr.Pas
//CE_Desc_Begin(SciPropertyMgr.pas)
{Load/Save properties from a TScintillaMemo/TScintilla derived component.}
//CE_Desc_End

//+++++++++++ TSciPropertyLoader

//CE_Desc_Begin(TSciPropertyLoader)
{Loads and saves properties for a TScintilla or descending component.

',' (Comma) is a special char. If the font/description contains ',' then
use the char '|' instead of ','. Otherwise it separates valueparts in styles.

This component saves the entire propertyfile to memory first, THEN it writes
it to the disk.. so if anything goes wrong while obtaining the data to save,
then the old settingfile is untouched.

<%BOLD%>What properties are supported?<%TEXT%>

<%BOLD%>Set Defaults<%TEXT%>
[default]
style=fore:clSilver,back:clBlack,size:15,font:Courier New,notbold,notitalics,notunderlined,visible,noteolfilled,changeable,nothotspot
WordWrap=False
Unicode=False
WordChars=_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789
ClearUndoAfterSave=False
CaretFore=clYellow
CaretBack=#202020
CaretLineVisible=False
CaretPeriod=500
CaretWidth=3
EOLMode=0
SelectForeColor=clHighlightText
SelectBackColor=clHighlight
MarkerForeColor=clYellow
MarkerBackColor=clBlue
BookMarkForeColor=clWhite
BookMarkBackColor=clGray
FoldMarginHighlightColor=clBlack
FoldMarginColor=clBlack
ActiveHotspotForeColor=clYellow
ActiveHotspotBackColor=clMaroon
ActiveHotspotUnderlined=True
ActiveHotspotSingleLine=True
Gutter=False
LineNumbers=True
EdgeColumn=0
EdgeMode=0
EdgeColor=clSilver
CodeFolding=True
FoldMarkerType=3
BraceHighlight=True

To set a property for a lexer (those defined inside the lexers),
add this section, and the settings you want.. Those you set
here apply to all languages..

[LexerProperties]
fold.preprocessor=1
tab.timmy.whinge.level=1

ALL below are under the language section:
[languageorlexername] (name of the Language or Lexer), i.e:

[C++/C]
name=value
name=value

<%BOLD%>Assigning a lexer to a language:<%TEXT%>

Set it like this:
lexer=lexername

Example:
lexer=cpp

defines the language in the current section as using the the 'cpp' lexer.

<%BOLD%>Defining Styles.<%TEXT%>

Set it like this:

style.99=name:Description,fore:clSilver,back:clBlack,size:15,font:Arial,notbold,notitalics,notunderlined,visible,noteolfilled,changeable,nothotspot

99 = stylenumber.
fore: = #000000 (value defined as a RGB hexadec, forecolor)
back: = #000000 (value defined as a RGB hexadec, backcolor)
size: Fontsize.
font: Fontname.
(not)bold = bold?
(not)italics = italic?
(not)underlined = underlined?
(not)visible = visible?
(not)eolfilled = eolfilled?
(not)changeable = changeable?
(not)hotspot = hotspot?

<%BOLD%>Defining Keywords.<%TEXT%>
Set it like this:

keywords.99=name:Description:: keywords separated by spaces

CommentBoxStart=/*
CommentBoxEnd=*/
CommentBoxMiddle=*
CommentBlock=//
CommentStreamStart=/*
CommentStreamEnd=*/
AssignmentOperator==
EndOfStatementOperator=;

<%BOLD%>Defining Extensions.<%TEXT%>

Define new extensions for the <%LINK TExtensionMapper.DetectLanguage%> function.
Set it like this:
[extensions]
lexer/languagetouse=.theextension;.theextension2;.theextension3
Example:
FUNNY=.wml;.wap;.data

defines the 'FUNNY' language as the handler of the .wml,.wap, and .data extension. This means that
when you call DetectLanguage, and the fileextension is '.wml' it returns 'FUNNY' as the
lexer/language to use. The last definition for a given extension is the handler used.

<%NOTE%>
All sections which contains either a style or a keywords statement
creates a new language with the name of the section if the language
doesn't yet exist.

All properties which doesn't match any of the named properties is stored
in a separate list which can be accessed by the functions <%LINK GetOther%>, <%LINK AddOther%>,
<%LINK GetBool%>, <%LINK AddBool%>, <%LINK GetInt%>, <%LINK AddInt%>.

All properties added with these AddOther procedure are also stored when you
save the propertyfile.

Please see the sourcecode in SciPropertyMgr.Pas for more info.
}
//CE_Desc_End
//CE_Desc_Begin(TSciPropertyLoader.GetOther)
{Retrieves the setting named 'settingname'. 'defaultvalue' is the default value if the
property isn't found. If 'addifnonexistent' is true then the property is added with the
default value if it does'nt exist.
}
//CE_Desc_End
//CE_Desc_Begin(TSciPropertyLoader.GetBool)
{Retrieves the setting named 'settingname'. 'defaultvalue' is the default value if the
property isn't found. If 'addifnonexistent' is true then the property is added with the
default value if it does'nt exist.
}
//CE_Desc_End
//CE_Desc_Begin(TSciPropertyLoader.GetInt)
{Retrieves the setting named 'settingname'. 'defaultvalue' is the default value if the
property isn't found. If 'addifnonexistent' is true then the property is added with the
default value if it does'nt exist.
}
//CE_Desc_End
//CE_Desc_Begin(TSciPropertyLoader.AddOther)
{Adds the setting named 'settingname' with the value 'valuename'.}
//CE_Desc_End
//CE_Desc_Begin(TSciPropertyLoader.AddInt)
{Adds the setting named 'settingname' with the value 'valuename'.}
//CE_Desc_End
//CE_Desc_Begin(TSciPropertyLoader.AddBool)
{Adds the setting named 'settingname' with the value 'valuename'.}
//CE_Desc_End
//CE_Desc_Begin(TSciPropertyLoader.Load)
{Load the properties from the <%LINK TSciPropertyLoader.FileName,FileName%> file.

Returns True if ok, and false if not.}
//CE_Desc_End
//CE_Desc_Begin(TSciPropertyLoader.Save)
{Saves the properties to the <%LINK TSciPropertyLoader.FileName,FileName%> file.

Returns True if ok, and false if not.}
//CE_Desc_End
//CE_Desc_Begin(TSciPropertyLoader.FillWithDefaultStyle)
{Fill the record 'sty' with the default styles.

The default styles are loaded from the property 'default.style' in the propertyfile.
}
//CE_Desc_End
//CE_Desc_Begin(TSciPropertyLoader.OnPropertiesLoaded)
{Fired when the propertyfile/stream is completely loaded. If you need to update settings
when a propertyfile is loaded, do it here.
}
//CE_Desc_End

//CE_Desc_Begin(TSciPropertyLoader.LoadFromStream)
{Load the properties from the specified stream.
Returns True if ok, and false if not.}
//CE_Desc_End
//CE_Desc_Begin(TSciPropertyLoader.SaveToStream)
{Saves the properties from the specified stream.
Returns True if ok, and false if not.}
//CE_Desc_End
//CE_Desc_Begin(TSciPropertyLoader.FileName)
{File where the settings are loaded/saved to.}
//CE_Desc_End
//CE_Desc_Begin(TSciPropertyLoader.Editor)
{Set this property to the TScintilla derived component to attach to.}
//CE_Desc_End
//CE_Desc_Begin(TSciPropertyLoader.OnLoadItem)
{Fired for each unknown property when loading.}
//CE_Desc_End
//CE_Desc_Begin(TSciPropertyLoader.OnSaveItem)
{Fired when saving properties.

Allows you to append additional properties when storing.}
//CE_Desc_End
//CE_Desc_Begin(TSciPropertyLoader.ProcessDataStart)
{Called for each property when loading.

<%BOLD%>Handles the properties/sections:<%TEXT%>
lexer.languagename, extension.newextension,
default.CaretFore, default.CaretBack, CaretPeriod, default.CaretLineVisible,
default.SelectForeColor, default.SelectBackColor, default.style,
default.WordWrap, default.Unicode, default.ClearUndoAfterSave, and default.CodeFolding
Returns False if it could'nt handled the property itself.
}
//CE_Desc_End
//CE_Desc_Begin(TSciPropertyLoader.ProcessDataEnd)
{Called for each property when loading.

<%BOLD%>Handles the properties:<%TEXT%>

style.languagename.stylenumber and keywords.languagename.keywordlistnumber.
}
//CE_Desc_End
//CE_Desc_Begin(TSciPropertyLoader.Notification)
{Sets Editor to nil if the linked editor is deleted.}
//CE_Desc_End

//CE_Desc_Begin(ExtMapper)
{Call this to get the <%LINK TExtensionMapper%> interface.

<%NOTE%>Do NOT free the returned classptr.}
//CE_Desc_End

//----------- SciSearchReplace.pas
//CE_Desc_Begin(SciSearchReplace.pas)
{Contains a component that provides search and replace functionality for the Scintilla Edit control including searching with regular expressions.}
//CE_Desc_End
//CE_Desc_Begin(TSciSearchReplace.Notification)
{Sets Editor to nil if the linked editor is deleted.}
//CE_Desc_End
//CE_Desc_Begin(TSciSearchReplace.ReplaceText)
{Text to replace the matched text with.}
//CE_Desc_End
//CE_Desc_Begin(TSciSearchReplace.ReplaceTextHistory)
{NOT DESCRIBED.}
//CE_Desc_End
//CE_Desc_Begin(TSciSearchReplace.SearchBackwards)
{Set to True if you want to search backwards.}
//CE_Desc_End
//CE_Desc_Begin(TSciSearchReplace.SearchCaseSensitive)
{Set to True if you want to search Case Sensitive.}
//CE_Desc_End
//CE_Desc_Begin(TSciSearchReplace.SearchFromCaret)
{Set to True if you want to search from the caret position.}
//CE_Desc_End
//CE_Desc_Begin(TSciSearchReplace.SearchRegex)
{Set to True if it's an regular expression.}
//CE_Desc_End
//CE_Desc_Begin(TSciSearchReplace.SearchSelectionOnly)
{Set to True if you only want to search the selected text.}
//CE_Desc_End
//CE_Desc_Begin(TSciSearchReplace.SearchText)
{The text/regex you want to search for.}
//CE_Desc_End
//CE_Desc_Begin(TSciSearchReplace.SearchTextHistory)
{NOT DESCRIBED.}
//CE_Desc_End
//CE_Desc_Begin(TSciSearchReplace.SearchWholeWords)
{Set to True if you only want to search whole words.}
//CE_Desc_End
//CE_Desc_Begin(TSciSearchReplace.FoundText)
{Found text.}
//CE_Desc_End


//+++++++++++ TSciSearchReplace

//CE_Desc_Begin(TSciSearchReplace)
{A component that provides search and replace functionality for the Scintilla Edit control including searching with regular expressions.}
//CE_Desc_End
//CE_Desc_Begin(TSciSearchReplace.DoSearchReplaceText)
{Repeat the last search/replace. If AReplace is True, then it replaces text, else
it just locates the text. If ABackwards is True, then is searches backwards.}
//CE_Desc_End
//CE_Desc_Begin(TSciSearchReplace.ShowSearchReplaceDialog)
{Show search/replace dialog. if AReplace are true, then it's a Replace dialog.}
//CE_Desc_End
//CE_Desc_Begin(TSciSearchReplace.SearchForSelWord)
{If true, searches for the selected word.}
//CE_Desc_End
//CE_Desc_Begin(TSciSearchReplace.Editor)
{Linked TScintilla component}
//CE_Desc_End
//CE_Desc_Begin(TSciSearchReplace.OnTextFound)
{Fired when matching text was found.}
//CE_Desc_End
//CE_Desc_Begin(TSciSearchReplace.OnTextNotFound)
{Fired when matching text was'nt found.}
//CE_Desc_End
//CE_Desc_Begin(TSciSearchReplace.OnTextReplaced)
{Fired when matching text was replaced.}
//CE_Desc_End

//----------- SciSearchTextDlg.pas
//CE_Desc_Begin(SciSearchTextDlg.pas)
{Search dialog. Used by the TSciSearchReplace component. Internal.}
//CE_Desc_End

//+++++++++++ TTextSearchDialog
//CE_Desc_Begin(TTextSearchDialog)
{Search dialog. Used by the TSciSearchReplace component. Internal.}
//CE_Desc_End
//----------- SciReplaceTextDlg.pas

//+++++++++++ TTextReplaceDialog
//CE_Desc_Begin(SciReplaceTextDlg.pas)
{Replace dialog. Used by the TSciSearchReplace component. Internal.}
//CE_Desc_End
//CE_Desc_Begin(TTextReplaceDialog)
{Replace dialog. Used by the TSciSearchReplace component. Internal.}
//CE_Desc_End
//----------- tcFontComboBox.pas
//CE_Desc_Begin(tcFontComboBox.pas)
{Font combobox with
 - small images for truetype ansi/symbol and printer fonts
 - fontnames displayed in font of item
 - small preview window
 - last used fonts at top above line and in given color.
}
//CE_Desc_End

//+++++++++++ TFormExampleFont

//CE_Desc_Begin(TFormExampleFont)
{Internal class, used by the TtcFontCombobox component.}
//CE_Desc_End

//CE_Desc_Begin(SciSupport.pas)
{The constants in this file was automatically generated from the Scintilla.iface interface definition
 file which contains any comments about the definitions.
 If you need to update this file with the new functionality of a newer scintilla version
 then you must use the scintilla.iface file which can be found in the Scintilla Project (www.scintilla.org)
 PasGen.py does the generation (requires Python).

 Please use the corresponding scintilla.iface file when you regenerate the code.
}
//CE_Desc_End
//----------- SciMacroRecording.Pas
//+++++++++++ TSciMacroRecorder
//CE_Desc_Begin(SciMacroRecording.Pas)
{The macrorecorder component.}
//CE_Desc_End

//CE_Desc_Begin(TSciMacroRecorder)
{Records a macro, can't store more than one at a time in memory for now.
Quite simple yet, but will be extended in later versions.
}
//CE_Desc_End
//CE_Desc_Begin(TSciMacroRecorder.Clear)
{Clears the current macro.}
//CE_Desc_End
//CE_Desc_Begin(TSciMacroRecorder.Execute)
{Executes the current macro.}
//CE_Desc_End
//CE_Desc_Begin(TSciMacroRecorder.LoadFromStream)
{Load a macro from a stream, and makes it current.}
//CE_Desc_End
//CE_Desc_Begin(TSciMacroRecorder.SaveToStream)
{Saves the current macro to a stream.}
//CE_Desc_End
//CE_Desc_Begin(TSciMacroRecorder.StartRecord)
{Starts recording a macro.}
//CE_Desc_End
//CE_Desc_Begin(TSciMacroRecorder.StopRecord)
{Stops the recording of a macro.}
//CE_Desc_End

//CE_Desc_Begin(sciUtils.Pas)
{Utility functions for Delphi Scintilla Interface Components. Not documented.}
//CE_Desc_End
